/ TINT Is Not T***** in PALbart assembly

/
/ Global symbols
/

/ ASCII chars
       ESC=033
       SPACE=040
       LF=012
       CR=015
       BRA=133

/ Autoindex locations
      AIX=010
      AIY=011

/ Constants
      FLDW=012      /Field height
      FLDH=026      /Field width
      FLDS=012^026  /Total size
      TERMW=0120    /Terminal width
      NL0002=CLA CLL CML RTL / Microcoded "2"
      NL7777=CLA CMA         / Microcoded "7777" or "-1"

/
/ Page zero global variables
/
       *20
DOWNMV, 0         / non-zero if last movement was down
PXPOS, 0          / Previous X,Y Position
PYPOS, 0
CXPOS, 0          / Current X,Y Position
CYPOS, 0
PSHAPE,SHAL0      / Previous shape
PSHSIZ,3          / Previous shape size
PSHROT,0          / Previous rotation
CSHAPE,SHAL0      / Current shape, init to first rotation of L
SHPSIZ,3          / Length of shape square.
SHPROT,0          / Current rotation index
SHPIDX,0          / Current index into SHPLST
SHPLST,SHAPEL     / List of pointers to shapes
       SHAPEJ
       SHAPES
       SHAPEZ
       SHAPET
       SHAPEO
       SHAPEI
TEMP,  0          / Temporaries used here and there
TEMP2, 0
LOOPI, 0          / Loop variables used here and there
LOOPJ, 0


/
/ Main loop.
/
       *200
       JMS INIT
       KCC
INPUT, KSF                    / Test keyboard flag
       JMP INPUT              / Input loop
       KRB                    / Read keystroke
       DCA TEMP               / Store key for later comparison
       TAD TEMP
       TAD (-"h+0200)         / Compare to h
       SNA CLA                / If zero, we got an 'h'
       JMP HKEY               / Go to handling of 'h'
       TAD TEMP               / If not, get keystroke again
       TAD (-"j+0200)         / Compare to j
       SNA CLA
       JMP JKEY
       TAD TEMP
       TAD (-"k+0200)         / Compare to k
       SNA CLA
       JMP KKEY
       TAD TEMP
       TAD (-"l+0200)         / Compare to l
       SNA CLA
       JMP LKEY
       TAD TEMP
       TAD (-"r+0200)         / Compare to r
       SNA CLA
       JMP RKEY
       JMP INPUT              / Unused key, return to input loop
/
/ Move left
/
HKEY,
       NL7777                 / Load -1
       TAD CXPOS              / Add current x position (move left)
       DCA CXPOS              / Store it
       JMP UPDATE             / Update screen
/
/ Move down
/
JKEY,
       ISZ CYPOS              / Increment current Y position
       ISZ DOWNMV             / Set downward move flag
       JMP UPDATE             / Update screen
/
/ Rotate clockwise
/
KKEY,
       TAD SHPROT             / Get current rotation
       IAC                    / Increment
       AND (3)                / Wrap arround so SHPROT is 0..3
       DCA SHPROT             / Store
       TAD (SHPLST)           / Get address to list of shapes
       TAD SHPIDX             / Add current shape index
       DCA CSHAPE             / Store pointer (use CSHAPE as temp store)
       TAD I CSHAPE           / Dereference to get shape descriptor pointer
       IAC                    / Skip size
       TAD SHPROT             / Jump to current rotation in descriptor array
       DCA CSHAPE             / Store pointer (again CSHAPE as temp store)
       TAD I CSHAPE           / Get current shapes current rotation
       DCA CSHAPE             / Store as current shape
       JMP UPDATE             / Update screen
/
/ Move right
/
LKEY,
       ISZ CXPOS              / Increment X position (move right)
       JMP UPDATE             / Update screen
/
/ Reset
/
RKEY,
       JMS INIT
       JMP INPUT

/
/ Update playing field and display
/
UPDATE,
       JMS IFILLM             / Check if current position is illegal
       JMP INPUT              / Then get next action

       TAD PXPOS              / Erase previous position
       CLL RAL                / Multiply by two (each block is double wide)
       TAD (TERMW%2-FLDW+1)   / Add field X offset (Starting column is 1)
       JMS ITOA               / Get ASCII X coordinate
       XPOS                   / Target address, argument for ITOA
       TAD PYPOS              / Get previous Y position
       IAC                    / Starting row is 1
       JMS ITOA               / Get ASCII Y coordinate
       YPOS                   / Target address, argument for ITOA
       TAD [MOVXY-1]          / Get pointer to move string
       JMS PUTS               / Position cursor
       TAD PSHAPE             / Get previous shape
       JMS DRAWS              / Clear it
       1                      / Argument for DRAWS, clear shape

       TAD CXPOS              / Draw new position
       CLL RAL                / Multiply by two (each block is double wide)
       TAD (TERMW%2-FLDW+1)   / Add field X offset (Starting column is 1)
       JMS ITOA               / Get ASCII X coordinate
       XPOS                   / Target address, argument for ITOA
       TAD CYPOS              / Get current Y position
       IAC                    / Starting row is 1
       JMS ITOA               / Get ASCII Y coordinate
       YPOS                   / Target address, argument for ITOA
       TAD [MOVXY-1]          / Get pointer to move string
       JMS PUTS               / Position cursor
       TAD CSHAPE             / Get current shape
       JMS DRAWS              / Draw it
       0                      / Argument for DRAWS. Do not clear, draw.

       TAD CXPOS              / Update previous positions after a move
       DCA PXPOS              / TODO implement MEMCPY
       TAD CYPOS
       DCA PYPOS
       TAD CSHAPE             / Update previous shape
       DCA PSHAPE
       TAD SHPROT
       DCA PSHROT
       TAD SHPSIZ
       DCA PSHSIZ
       DCA DOWNMV             / Reset DOWNMV boolean
       JMP INPUT              / Get next action

PAGE

ILLPOS, 0
FIXSHP,0
       / First setup shape data iterator
       NL7777
       TAD CSHAPE
       DCA AIX                   / Location of shape is in AC. Store in index register
       TAD SHPSIZ                  / Get size
       CIA                       / Invert for loop use
       DCA LOOPJ                 / Store as outer loop index

       JMS CALCPO         / Get position within field in AC
       DCA ILLPOS

ILLOOP,
       TAD SHPSIZ
       CIA
       DCA LOOPI
JLLOOP,
       TAD I AIX
       SZA
       DCA I ILLPOS       / Put something in field
       ISZ ILLPOS          / Increment field pointer
       ISZ LOOPI
       JMP JLLOOP

       TAD SHPSIZ
       CIA
       TAD ILLPOS
       TAD (FLDW)
       DCA ILLPOS
       ISZ LOOPJ
       JMP ILLOOP
       JMP I FIXSHP

/
/ Spawns new shape
/
SPNSHP,0
       DCA CXPOS          / TODO implement MEMCLR (and MEMMOV)
       DCA CYPOS
       DCA PXPOS
       DCA PYPOS
       DCA DOWNMV         / Reset DOWNMV boolean
       JMS INIT
       NL0002             / Add two to SHPIDX (1 to get into 1..7 range, and 1 to increment)
       TAD SHPIDX         / Get SHPIDX
       AND (7)            / Wrap arround at 7
       SZA                / If wrapped to 0
       TAD (-1)           / Remove one, thus index is 0..6
       DCA SHPIDX         / Save
       TAD (SHPLST)         / Get SHPLST address
       TAD SHPIDX         / Add index
       DCA CSHAPE         / Temporary store in current shape pointer
       TAD I CSHAPE       / Get pointer to shape descriptor
       DCA CSHAPE         / Again use CSHAPE as temp
       TAD I CSHAPE       / Get size
       DCA SHPSIZ         / Store size val
       ISZ CSHAPE         / Skip size
       TAD CSHAPE         / Get pointer to shape rotation list
       TAD SHPROT         / Get current rotation
       DCA CSHAPE         / Again store temporarily in CSHAPE
       TAD I CSHAPE       / Get pointer to actual shape
       DCA CSHAPE         / Store as current shape pointer
       JMP I SPNSHP

/
/ Init
/

INIT,  0
       TAD (ERASE-1)   / Load erase escape sequence
       JMS PUTS        / Output to terminal
       DCA CXPOS       / Reset positions
       DCA PXPOS / TODO reset all zero page variables
       DCA CYPOS
       DCA PYPOS
       TAD (TERMW%2-FLDW-2)  / Starting XPOS is middle of terminal
       IAC / start column is 1
       JMS ITOA
       XPOS                   / Target address, argument for ITOA
       CLA IAC                / start row is 1
       JMS ITOA
       YPOS                   / Target address, argument for ITOA
       TAD [MOVXY-1]
       JMS PUTS
/       JMS BLNKF       / Reset game field
       JMS DRAWF       / Draw empty field
       JMP I INIT      / Return


/
/ Do one of:
/


/
/ 2. Perform drop to bottom
/

/
/ 4. Perform normal drop
/

PAGE

/ Calculate FLDPOS, leave in AC

CALCPO,0
       TAD CYPOS                 / Get current Y position
       CMA                       / Invert for loop
       DCA LOOPI                 / Put in location loop
       TAD (FIELDP)               / Get field pointer
       JMP .+2                   / Skip first add
ILOOP, TAD (FLDW)                / Add field width to get to next row
       ISZ LOOPI                 / Loop check
       JMP ILOOP
       TAD CXPOS                 / Add X offset
       JMP I CALCPO

/
/ Check possibility
/
/ See if the current posistion/rotation is possible, otherwise restore
/ previous state. First argument is shape.
/

FIELDX,0
FIELDY,0
FLDPOS,0
IFILLM,0
       NL7777                 / First setup shape data iterator
       TAD CSHAPE
       DCA AIX                / AIX is first index register
       TAD SHPSIZ             / Get size
       CIA                    / Invert for loop use
       DCA LOOPJ              / Store as outer loop index

       JMS CALCPO             / Calculate position in field
       DCA FLDPOS             / Store it

       TAD CXPOS              / Get X and Y posistion for later checks
       DCA FIELDX
       TAD CYPOS
       DCA FIELDY

LSHROW,                       / Loop over rows in shape
       TAD SHPSIZ             / Get size again
       CIA                    / Invert for loop use
       DCA LOOPI              / Stor as inner loop index

LSHCOL,                       / Inner loop over columns in shape
       TAD I AIX              / Get shape data
       SNA CLA                / If zero, continue to next pos
       JMP LDCONT
                              / Else check field for collision
                              / 1st. check if X is out of bounds
       TAD FIELDX             / Get X
       SPA CLA                / Check if negative
       JMP PRVPOS             / Yes, return
       TAD (-FLDW)            / Get negative width
       TAD FIELDX             / Add X
       SMA CLA                / Check if positive (FIELDX to big)
       JMP PRVPOS             / Yes, return

                              / 2nd. check y overflow
       TAD (-FLDH)            / Get negative width
       TAD FIELDY             / Add Y
       SMA CLA                / Check if positive (FIELDY to big)
       JMP PRVPOS             / Yes, return

                              / 3. check content
       TAD I FLDPOS           / Get content
       SZA CLA                / Check if it contains block
       JMP PRVPOS             / Yes, return

LDCONT,                       / If we get here, there was no collision
       ISZ FLDPOS             / Move one step in the game field
       ISZ FIELDX             / Increment field X posistion (can be negative)
       NOP
       ISZ LOOPI              / Increment inner loop, one block processed
       JMP LSHCOL             / Go to next column

       TAD CXPOS              / Inner loop done
       DCA FIELDX             / Store starting X position
       TAD SHPSIZ             / Get width
       CIA                    / Subtract from field position
       TAD FLDPOS             / Get current field position
       TAD (FLDW)             / Move field position to next row
       DCA FLDPOS
       ISZ FIELDY             / Update Y position
       ISZ LOOPJ              / Increment outer loop, one row done
       JMP LSHROW             / Go to next row
       ISZ IFILLM             / legal move, increment return address
       JMP I IFILLM           / All rows done, return to caller.

PRVPOS,                       / Restore position, rotation, shape and size
       TAD PXPOS
       DCA CXPOS
       TAD PYPOS
       DCA CYPOS
       TAD PSHAPE
       DCA CSHAPE
       TAD PSHROT
       DCA SHPROT
       TAD PSHSIZ
       DCA SHPSIZ
       TAD DOWNMV             / Was this a downwards move?
       SNA CLA
       JMP .+3
       JMS FIXSHP             / Yes, make shape permanent in field
       JMS SPNSHP             / And spawn new shape
       JMP I IFILLM           / Return

/
/ Wallkick translation
/

/
/ Check if we have reached "bottom" and timer expired.
/

/
/ Spawn new block
/

/
/ Check for solid lines
/

/
/ Erase lines
/

/
/ Gravitate field
/

/
/ Calculate hat of seven
/

/
/ Erase "oldpos"
/

/
/ Draw "newpos"
/

/
/ Draw field
/
PAGE
DRAWF, 0
       CLA
/       TAD (FIELDP-01+FLDW+FLDW   / Skip two invisible top lines
       TAD (FIELDP-01
       DCA AIX
/       TAD (FLDH-02              / Loop over visible rows
       TAD (FLDH
       CIA
       DCA LOOPI
ROWS,
       TAD (FLDW                 / Loop over columns
       CIA
       DCA LOOPJ
       TAD ("<                   / Start by outputing <!
       JMS PUTC
       TAD ("!
       JMS PUTC
COLS,
       TAD I AIX                 / Get cell
       SNA CLA                   / Nonzero means a block
       JMP ISBLNK
ISBLCK,
       TAD ("[
       JMS PUTC
       TAD ("]
       JMS PUTC
       JMP ENDCELL
ISBLNK,
       TAD (".
       JMS PUTC
       TAD (".
       JMS PUTC
ENDCELL,
       ISZ LOOPJ
       JMP COLS                  / Column loop end
       TAD ("!                   / End by outputing !>
       JMS PUTC
       TAD (">
       JMS PUTC
       TAD (MOVD-1               / And move cursor down and back
       JMS PUTS
       TAD ("2                   / Move back 24. TODO do this once
       DCA BACK
       TAD ("4
       DCA BACK+1
       TAD (MOVB-1
       JMS PUTS
       ISZ LOOPI                 / Loop over number of rows
       JMP ROWS
       JMP I DRAWF               / Return

/
/ Draw shape, AC contains location
/
DRAWS, 0
       TAD (-1)
       DCA AIX                   / Location of shape is in AC. Store in index register
       TAD SHPSIZ                / Get size
       CIA                       / Invert for loop use
       DCA LOOPJ                 / Store as outer loop index
BROWS,
       CLA
       TAD SHPSIZ                / Get size again
       CIA                       / Invert for loop use
       DCA LOOPI                 / Stor as inner loop index
BCOLS,
       TAD I AIX                 / Walk through shape data
       SZA CLA                   / If zero, draw blank
       JMP DBLCK                 / Else draw block
DBLNK,
       TAD (MOVF-1               / Move cursor to "draw" transparent block
       JMS PUTS
       TAD (MOVF-1
       JMS PUTS
       JMP DCONT                 / Continue loop
DBLCK,
       TAD I DRAWS               / First argument, should we clear?
       SZA CLA                   / if non-zero
       JMP DCBLCK                / We should clear block
       TAD ("[                   / Draw block by outputing [] pair
       JMS PUTC
       TAD ("]
       JMS PUTC
       JMP DCONT
DCBLCK,
       TAD (".)                  / Clear block by outputing two dots
       JMS PUTC
       TAD (".)
       JMS PUTC
DCONT,
       ISZ LOOPI                 / Increment inner loop, one block processed
       JMP BCOLS                 / Go to next column
       TAD ("0                   / Move back twize the size of shape
       DCA BACK
       TAD ("0
       TAD SHPSIZ
       TAD SHPSIZ
       DCA BACK+1
       TAD (MOVB-1
       JMS PUTS
       TAD (MOVD-1
       JMS PUTS                 / Move down
       ISZ LOOPJ                / Increment outer loop, one row done
       JMP BROWS                / Go to next row
       ISZ DRAWS                / Skip over argumnet
       NOP
       JMP I DRAWS              / All rows done, return to caller.

PAGE
/ TODO save space by storing shape data as bit fields
SHAPEL,3;SHAL0;SHAL1;SHAL2;SHAL3

SHAL0,   0;0;1
         1;1;1
         0;0;0

SHAL1,   0;1;0
         0;1;0
         0;1;1

SHAL2,   0;0;0
         1;1;1
         1;0;0

SHAL3,   1;1;0
         0;1;0
         0;1;0

SHAPEJ,3;SHAJ0;SHAJ1;SHAJ2;SHAJ3

SHAJ0,   1;0;0
         1;1;1
         0;0;0

SHAJ1,   0;1;1
         0;1;0
         0;1;0

SHAJ2,   0;0;0
         1;1;1
         0;0;1

SHAJ3,   0;1;0
         0;1;0
         1;1;0


SHAPES,3;SHAS0;SHAS1;SHAS2;SHAS3

SHAS0,   0;1;1
         1;1;0
         0;0;0

SHAS1,   0;1;0
         0;1;1
         0;0;1

SHAS2,   0;0;0
         0;1;1
         1;1;0

SHAS3,   1;0;0
         1;1;0
         0;1;0

SHAPEZ,3;SHAZ0;SHAZ1;SHAZ2;SHAZ3

SHAZ0,   1;1;0
         0;1;1
         0;0;0

SHAZ1,   0;0;1
         0;1;1
         0;1;0

SHAZ2,   0;0;0
         1;1;0
         0;1;1

SHAZ3,   0;1;0
         1;1;0
         1;0;0

SHAPET,3;SHAT0;SHAT1;SHAT2;SHAT3

SHAT0,   0;1;0
         1;1;1
         0;0;0

SHAT1,   0;1;0
         0;1;1
         0;1;0

SHAT2,   0;0;0
         1;1;1
         0;1;0

SHAT3,   0;1;0
         1;1;0
         0;1;0

SHAPEO,4;SHAO0;SHAO1;SHAO2;SHAO3

SHAO0,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAO1,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAO2,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAO3,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAPEI,4;SHAI0;SHAI1;SHAI2;SHAI3

SHAI0,   0;0;0;0
         1;1;1;1
         0;0;0;0
         0;0;0;0

SHAI1,   0;0;1;0
         0;0;1;0
         0;0;1;0
         0;0;1;0

SHAI2,   0;0;0;0
         0;0;0;0
         1;1;1;1
         0;0;0;0

SHAI3,   0;1;0;0
         0;1;0;0
         0;1;0;0
         0;1;0;0
/
/ Blank field
/

BLNKF, 0
       CLA
       TAD (FLDS                 / Get field size
       CIA / TODO negate the above and bum CIA
       DCA LOOPI
       TAD (FIELD-1              / Get field location
       DCA AIX
BLOOP,
       DCA I AIX                 / Put 0 in FIELD through AIX
       ISZ LOOPI
       JMP BLOOP
       JMP I BLNKF               / Return

/
/ Output one char, clear AC
/

PUTC,  0
       TLS
       TSF
       JMP .-1
       CLA
       JMP I PUTC

/
/ Output null terminated string, one char per word. AC is loc-1
/
PUTS,   0
        DCA AIY
PLOOP,
        TAD I AIY
        SNA
        JMP I PUTS
        JMS PUTC
        JMP PLOOP

PAGE

/
/ Output null terminated mixed case packed string. AC is string loc-1
/
/ TODO allow escaping to Upper/Lower case only
PUTPS,  0
        DCA AIY
PSLOOP,
        TAD I AIY             / Load first word
        DCA TEMP               / Stash word
        TAD TEMP
        BSW                   / Move first half down
        AND (077)
        JMS PUTB              / Unpack one byte
        TAD TEMP               / Get next byte
        AND (077)
        JMS PUTB
        JMP PSLOOP
PUTB,   0
        SNA
        JMP I PUTPS           / Null byte, return
        DCA TEMP2              / Stash byte
        TAD TEMP2
        AND (037)             / Check if space char (five zero bits)
        SZA
        JMP NOSPC
        TAD (040)             / Set space bit otherwise we output `
        JMP ISSPC             / TODO check for actual space, now we miss @
NOSPC,
        CLA
        /TAD TEMP2 / For uppercase version
        /AND (40)
        /SNA CLA
        TAD (100)             / Not space? set char bit
        TAD TEMP2
ISSPC,
        JMS PUTC              / Output
        JMP I PUTB

/
/ Move to X,Y
/
MOVXY,  ESC
        BRA  / [
YPOS,   0
        0
        073  / ;
XPOS,   0
        0
        0110 / H
        0

/
/ Move up
/
MOVU,  ESC
       BRA
UP,    "1
       "A
       0

/
/ Move down
/
MOVD,  ESC
       BRA
DOWN,  "1
       "B
       0

/
/ Move forward
/
MOVF, ESC
      BRA
FORW, "0
      "1
      "C
      0

/
/ Move backward
/
MOVB, ESC
      BRA
BACK, "2
      "4
      "D
      0

/
/ Clear screen
/
ERASE,  ESC
        133 / [
        "2
        "J
        0

PAGE

/
/ ITOA - Convert integer between 0-99 to double digit ASCII
/        AC has value, ITOA+1 has target address.
/

VALUE,  0
TARGET, 0
ITOA,   0
        DCA VALUE             / Store value to be converterd
        TAD I ITOA            / Get the first argument
        DCA TARGET            / Store it
        ISZ ITOA              / Advance return address
        NOP
        TAD ("0)              / Get ASCII value of 0
        DCA I TARGET          / Store as initial value in target
        TAD VALUE             / Get value
LOOP10, TAD (-12)             / Remove decimal 10
        SPA                   / While value is still positive
        JMP NXTDGT            / Then go to calculating next digit
        ISZ I TARGET          / Increment ASCII value
        JMP LOOP10

NXTDGT, ISZ TARGET            / Advance target pointer
        NOP
        TAD ("0+12)           / Get ASCII 0 + 10 since subtracted 10 below 0
        DCA I TARGET          / Store as result in target
        JMP I ITOA            / Return

/
/ Reserve space for game field
/
       PAGE
FIELDP, ZBLOCK FLDS
/       *FIELDP+FLDS
FLDEND, HLT
$
