/ TINT Is Not T***** in PALbart assembly

/
/ Global symbols
/

/ ASCII chars
       ESC=033
       SPACE=040
       LF=012
       CR=015
       BRA=133

/ Autoindex locations
      AIX=010
      AIY=011

/ Constants
      FLDW=012                / Field height
      FLDH=026                / Field width
      FLDS=012^026            / Total size
      TERMW=0120              / Terminal width
      NL0002=CLA CLL CML RTL  / Microcoded "2"
      NL7777=CLA CMA          / Microcoded "7777" or "-1"

/
/ Page zero global variables
/
       *20

/
/ Shape structures. The current shape and previous shape structure must
/ be of equal size and the variables must be in the same order as the
/ current shape data is copied to the previous shape data when a new
/ block is spawned.
/

CSHAPE,SHAL0                  / Current shape, init to first rotation of L
CXPOS, 0                      / Current X,Y Position
CYPOS, 0
CSHROT,0                      / Current rotation index
CSHSIZ,3                      / Length of shape square.

PSHAPE,SHAL0                  / Previous shape
PXPOS, 0                      / Previous X,Y Position
PYPOS, 0
PSHROT,0                      / Previous rotation
PSHSIZ,3                      / Previous shape size

/
/ Down movement boolean, must be first variable after shape structures,
/ it's used to determine their combined size.
/
DOWNMV,0                      / non-zero if last movement was down
HRDDRP,0                      / User pressed space, hard drop in progress.

SHPIDX,0                      / Current index into SHPLST
SHPLST,SHAPEL                 / List of pointers to shapes
       SHAPEJ
       SHAPES
       SHAPEZ
       SHAPET
       SHAPEO
       SHAPEI
TEMP,  0                      / Temporaries used here and there
TEMP2, 0
LOOPI, 0                      / Loop variables used here and there
LOOPJ, 0

/
/ Time limits
/
/ This code should run on a CPU without real time clock. So we
/ maintain a few "timers" which is just counters. When they reach 0
/ they have timed out. A positive limit just means that the time
/ must wrap arround.
/
/ Timers and their limits should go in the same order, TIMER1 and
/ LIMIT1 must be first as timers are reset by MEMCPYing data at
/ LIMIT1..LIMIT1+(LIMIT1-TIMER1) to TIMER1


TIMER1, 0                     / Main timer for gravity.
TIMER2, -70                   / Two timers necessary for fast CPUs
HRDTIM, -1000                 / Hard drop timer
LIMIT1, 0                     / TIMER1 limit
LIMIT2, -70                   / TIMER2 limit
HRDLIM, -1000                 / Hard drop limit

/
/ Globally usefull routines
/

/
/ MEMSET, set memory region to value.
/
/ ARG0 is pointer to region
/ ARG1 is size
/ ARG2 is value
/
/ Size must be >= 1
/

MEMSET,0
       NL7777                 / Load -1
       TAD I MEMSET           / Get address -1
       DCA AIX                / Store in autoindex register
       ISZ MEMSET             / Get next argument
       TAD I MEMSET           / Which is size
       CIA                    / Negate for loop
       DCA LOOPI              / Put in loop variable
       ISZ MEMSET             / Get next argument (value to set)
MSLOOP,
       TAD I MEMSET           / Get value argument
       DCA I AIX              / Store value through autoindex
       ISZ LOOPI              / Is loop done?
       JMP MSLOOP             / No, continue
       ISZ MEMSET             / Yes, setup return address
       JMP I MEMSET           / return

/
/ MEMCPY, copy one region of memory to another
/
/ ARG0 is source address
/ ARG1 is target address
/ ARG2 is size
/
/ Size must be >= 1
/

MEMCPY,0
       NL7777                 / Load -1
       TAD I MEMCPY           / Get source address -1
       DCA AIX                / Store in autoindex register
       ISZ MEMCPY             / Get next argument
       NL7777                 / Load -1
       TAD I MEMCPY           / Which is target address -1
       DCA AIY                / Store in autoindex register
       ISZ MEMCPY             / Get next argument
       TAD I MEMCPY           / Which is size
       CIA                    / Negate for loop use
       DCA LOOPI              / Put in loop variable
       ISZ MEMCPY             / Setup return address
MCLOOP,
       TAD I AIX              / Get value from source
       DCA I AIY              / Store in target
       ISZ LOOPI              / Is loop done?
       JMP MCLOOP             / No, continue
       JMP I MEMCPY           / Yes, return

/
/ Output one char, clear AC
/

PUTC,  0
       TLS                    / Initiate output of content in AC
       TSF                    / Is tty flag set?
       JMP .-1                / No, wait some more
       CLA                    / Yes, Clean up AC
       JMP I PUTC             / Return

/
/ Output null terminated string, one char per word. AC is loc-1
/

PUTS,   0
        DCA AIY               / Set up autoindex register
PLOOP,
        TAD I AIY             / Get next char
        SNA                   / Is it zero?
        JMP I PUTS            / Yes, return
        JMS PUTC              / No, output char
        JMP PLOOP             / Do again

/
/ ITOA - Convert integer between 0-99 to double digit ASCII
/        AC has value, ITOA+1 has target address.
/

VALUE,  0
TARGET, 0
ITOA,   0
        DCA VALUE             / Store value to be converterd
        TAD I ITOA            / Get the first argument
        DCA TARGET            / Store it
        ISZ ITOA              / Advance return address
        NOP
        TAD ("0)              / Get ASCII value of 0
        DCA I TARGET          / Store as initial value in target
        TAD VALUE             / Get value
LOOP10, TAD (-12)             / Remove decimal 10
        SPA                   / While value is still positive
        JMP NXTDGT            / Then go to calculating next digit
        ISZ I TARGET          / Increment ASCII value
        JMP LOOP10

NXTDGT, ISZ TARGET            / Advance target pointer
        NOP
        TAD ("0+12)           / Get ASCII 0 + 10 since subtracted 10 below 0
        DCA I TARGET          / Store as result in target
        JMP I ITOA            / Return

/
/ Main loop.
/
       *200
       JMS INIT
       KCC
MAIN,  TAD HRDDRP             / Get hard drop flag
       SNA CLA                / Is a hard drop in progress?
       JMP TCONT              / No, continue to next timer
       ISZ HRDTIM             / Yes, has hard drop delay timed out?
       JMP MAIN               / No, check again
       TAD HRDLIM             / Yes, reset hard drop timer
       DCA HRDTIM
       JMP JKEY               / And fake a down move
TCONT, ISZ TIMER1             / Has drop delay timed out?
       JMP INPUT              / No, get input
       ISZ TIMER2             / Yes, has drop delay two also timed out?
       JMP INPUT              / No, get input
       TAD LIMIT1             / Yes reset both timers
       DCA TIMER1
       TAD LIMIT2
       DCA TIMER2
       JMP JKEY               / Then fake a down move
INPUT, KSF                    / Test keyboard flag
       JMP MAIN               / Main event loop
       KRB                    / Read keystroke
       AND (37)               / Get lower bits (no "partiy" or case bits)
       DCA TEMP               / Store key for later comparison
       TAD TEMP
       TAD (-10)              / Compare to h
       SNA CLA                / If zero, we got an 'h'
       JMP HKEY               / Go to handling of 'h'
       TAD TEMP               / If not, get keystroke again
       TAD (-12)              / Compare to j
       SNA CLA
       JMP JKEY
       TAD TEMP
       TAD (-13)              / Compare to k
       SNA CLA
       JMP KKEY
       TAD TEMP
       TAD (-14)              / Compare to l
       SNA CLA
       JMP LKEY
       TAD TEMP
       TAD (-21)              / Compare to q
       SNA CLA
       HLT
       TAD TEMP
       TAD (-22)              / Compare to r
       SNA CLA
       JMP RKEY
       TAD TEMP
       SNA CLA                / Compare to space (zero)
       JMP SPCKEY
       JMP MAIN               / Unused key, return to input loop
/
/ Move left
/
HKEY,
       NL7777                 / Load -1
       TAD CXPOS              / Add current x position (move left)
       DCA CXPOS              / Store it
       JMP UPDATE             / Update screen
/
/ Move down
/
JKEY,
       ISZ CYPOS              / Increment current Y position
       ISZ DOWNMV             / Set downward move flag
       JMP UPDATE             / Update screen
/
/ Rotate clockwise
/
KKEY,
       TAD CSHROT             / Get current rotation
       IAC                    / Increment
       AND (3)                / Wrap arround so CSHROT is 0..3
       DCA CSHROT             / Store
       TAD (SHPLST)           / Get address to list of shapes
       TAD SHPIDX             / Add current shape index
       DCA CSHAPE             / Store pointer (use CSHAPE as temp store)
       TAD I CSHAPE           / Dereference to get shape descriptor pointer
       IAC                    / Skip size
       TAD CSHROT             / Jump to current rotation in descriptor array
       DCA CSHAPE             / Store pointer (again CSHAPE as temp store)
       TAD I CSHAPE           / Get current shapes current rotation
       DCA CSHAPE             / Store as current shape
       JMP UPDATE             / Update screen
/
/ Move right
/
LKEY,
       ISZ CXPOS              / Increment X position (move right)
       NOP                    / X might transition from -1 to 0
       JMP UPDATE             / Update screen
/
/ Reset
/
RKEY,
       JMS INIT               / Clear field, reset variables
       JMP MAIN               / Start over, get next action

/
/ Hard drop
/
SPCKEY,
       ISZ HRDDRP             / Set hard drop flag
       JMP MAIN               / Handle drop in main event loop
/
/ Update playing field and display
/
UPDATE,
       JMS IFILLM             / Check if current position is illegal
       JMP MAIN               / Then get next action

/
/ Erase "oldpos"
/

       TAD PXPOS              / Erase previous position
       CLL RAL                / Multiply by two (each block is double wide)
       TAD (TERMW%2-FLDW+1)   / Add field X offset (Starting column is 1)
       JMS ITOA               / Get ASCII X coordinate
       XPOS                   / Target address, argument for ITOA
       TAD PYPOS              / Get previous Y position
       IAC                    / Starting row is 1
       JMS ITOA               / Get ASCII Y coordinate
       YPOS                   / Target address, argument for ITOA
       TAD [MOVXY-1]          / Get pointer to move string
       JMS PUTS               / Position cursor
       TAD PSHAPE             / Get previous shape
       JMS DRAWS              / Clear it
       1                      / Argument for DRAWS, clear shape

/
/ Draw "newpos"
/

       TAD CXPOS              / Draw new position
       CLL RAL                / Multiply by two (each block is double wide)
       TAD (TERMW%2-FLDW+1)   / Add field X offset (Starting column is 1)
       JMS ITOA               / Get ASCII X coordinate
       XPOS                   / Target address, argument for ITOA
       TAD CYPOS              / Get current Y position
       IAC                    / Starting row is 1
       JMS ITOA               / Get ASCII Y coordinate
       YPOS                   / Target address, argument for ITOA
       TAD [MOVXY-1]          / Get pointer to move string
       JMS PUTS               / Position cursor
       TAD CSHAPE             / Get current shape
       JMS DRAWS              / Draw it
       0                      / Argument for DRAWS. Do not clear, draw.

       JMS MEMCPY             / Update previous positions after a move
       CSHAPE                 / ARG for MEMCPY, copy from current shape
       PSHAPE                 / ARG for MEMCPY, copy to previous shape
       PSHAPE-CSHAPE          / ARG for MEMCPY, size of struct

       DCA DOWNMV             / Reset DOWNMV boolean
       JMP MAIN               / Get next action

PAGE

/
/ FIXPOS, make the current shape permanent at the current position in
/ the game field.
/

FIXPOS,0
FIXSHP,0
       NL7777                 / First setup shape data iterator
       TAD CSHAPE             / Get location of current shape-1
       DCA AIX                / Store in auto index register

       JMS CALCPO             / Get position within game field
       DCA FIXPOS             / Store

       TAD CSHSIZ             / Get size
       CIA                    / Invert for loop use
       DCA LOOPI              / Store as outer loop index
FILOOP,
       TAD CSHSIZ             / Get size again
       CIA                    / Invert for inner loop
       DCA LOOPJ              / Store as inner loop index
FJLOOP,
       TAD I AIX              / Get next block in shape
       SZA                    / Is it zero?
       DCA I FIXPOS           / No, Put it in game field
       ISZ FIXPOS             / Increment field pointer
       ISZ LOOPJ              / Is loop done?
       JMP FJLOOP             / No, get next block in row

       TAD CSHSIZ             / Get shape size again
       CIA                    / Subtract from:
       TAD FIXPOS             / Field position
       TAD (FLDW)             / Add width to get start of next row
       DCA FIXPOS             / Store updated position
       ISZ LOOPI              / Is outer loop done?
       JMP FILOOP             / No, do next row
       JMP I FIXSHP           / Yes, return

/
/ SPNSHP, spawns new shape by resetting current shape structure and
/ getting the next shape in the global shape list.
/
/ TODO, permute shapelist when SHPIDX wraps to get "bag of seven"
/ behaviour.
/

SPNSHP,0
       JMS MEMSET             / Reset all current and previous values
       CSHAPE                 / Arg for MEMSET, starting position
       DOWNMV+1-CSHAPE        / size of all variables including DOWNMV
       0                      / Value to set
       NL0002                 / Add two to SHPIDX (1 to get into 1..7 range, and 1 to increment)
       TAD SHPIDX             / Get SHPIDX
       AND (7)                / Wrap arround at 7
       SZA                    / Did it wrap to 0 ?
       TAD (-1)               / No, remove one, so index is 0..6
       DCA SHPIDX             / Save
       TAD (SHPLST)           / Get SHPLST address
       TAD SHPIDX             / Add index
       DCA CSHAPE             / Temporary store in current shape pointer
       TAD I CSHAPE           / Get pointer to shape descriptor
       DCA CSHAPE             / Again use CSHAPE as temp
       TAD I CSHAPE           / Get size
       DCA CSHSIZ             / Store size val
       ISZ CSHAPE             / Skip size
       TAD CSHAPE             / Get pointer to shape rotation list
       DCA CSHAPE             / Again store temporarily in CSHAPE
       TAD I CSHAPE           / Get pointer to actual shape
       DCA CSHAPE             / Store as current shape pointer
       TAD CSHAPE             / Get shape pointer again
       DCA PSHAPE             / And use it to init previous pointer
       TAD CSHSIZ             / Get size
       DCA PSHSIZ             / And init previous size
       JMS MEMCPY             / Reset timers
       LIMIT1                 / ARG for MEMCPY, copy from limits
       TIMER1                 / ARG for MEMCPY, copy to timers
       LIMIT1-TIMER1          / ARG for MEMCPY, number of timers
       JMP I SPNSHP

/
/ Init
/

INIT,  0
       JMS MEMSET             / Reset game field
       FIELDP                 / Arg for MEMSET, pointer to field
       FLDS                   / Arg for MEMSET, field size
       0                      / Arg for MEMSET, value to set
       TAD (ERASE-1)          / Load erase escape sequence
       JMS PUTS               / Output to terminal
       TAD (TERMW%2-FLDW-2+1) / Starting XPOS is middle of terminal (Start column is 1)
       JMS ITOA               / Get ASCII coordinate
       XPOS                   / Target address, argument for ITOA
       CLA IAC                / Start row is 1
       JMS ITOA               / Get ASCII Y coordinate
       YPOS                   / Target address, argument for ITOA
       TAD [MOVXY-1]          / Position cursors
       JMS PUTS
       JMS DRAWF              / Draw empty field
       JMS SPNSHP             / Spawn a new shape
       JMP I INIT             / Return


/
/ Do one of:
/


/
/ 2. Perform drop to bottom
/

/
/ 4. Perform normal drop
/

PAGE

/
/ CALCPO Calculate FLDPOS, leave in AC
/
CALCPO,0
       TAD CYPOS              / Get current Y position
       CMA                    / Negate and subtract 1
       DCA LOOPI              / Store in loop index
       TAD (FIELDP)           / Get field pointer
       JMP .+2                / Skip first add (since Y starts at 0)
ILOOP, TAD (FLDW)             / Add field width to get to next row
       ISZ LOOPI              / Is Y zero?
       JMP ILOOP              / No, add width again
       TAD CXPOS              / Add X offset
       JMP I CALCPO           / Return

/
/ Check possibility
/
/ See if the current posistion/rotation is possible, otherwise restore
/ previous state. First argument is shape.
/

FIELDX,0
FIELDY,0
FLDPOS,0
IFILLM,0
       NL7777                 / First setup shape data iterator
       TAD CSHAPE
       DCA AIX                / AIX is first index register
       TAD CSHSIZ             / Get size
       CIA                    / Invert for loop use
       DCA LOOPJ              / Store as outer loop index

       JMS CALCPO             / Calculate position in field
       DCA FLDPOS             / Store it

       TAD CXPOS              / Get X and Y posistion for later checks
       DCA FIELDX
       TAD CYPOS
       DCA FIELDY

LSHROW,                       / Loop over rows in shape
       TAD CSHSIZ             / Get size again
       CIA                    / Invert for loop use
       DCA LOOPI              / Stor as inner loop index

LSHCOL,                       / Inner loop over columns in shape
       TAD I AIX              / Get shape data
       SNA CLA                / Is shape data zero/blank?
       JMP LDCONT             / Yes, continue with next block
                              / No, check field for collision
                              / 1st. check if X is out of bounds
       TAD FIELDX             / Get X
       SPA CLA                / Check if negative
       JMP PRVPOS             / Yes, return
       TAD (-FLDW)            / Get negative width
       TAD FIELDX             / Add X
       SMA CLA                / Check if positive (FIELDX to big)
       JMP PRVPOS             / Yes, return

                              / 2nd. check y overflow
       TAD (-FLDH)            / Get negative width
       TAD FIELDY             / Add Y
       SMA CLA                / Check if positive (FIELDY to big)
       JMP PRVPOS             / Yes, return

                              / 3. check content
       TAD I FLDPOS           / Get content
       SZA CLA                / Check if it contains block
       JMP PRVPOS             / Yes, return

LDCONT,                       / If we get here, there was no collision
       ISZ FLDPOS             / Move one step in the game field
       ISZ FIELDX             / Increment field X posistion (can be negative)
       NOP
       ISZ LOOPI              / Increment inner loop, one block processed
       JMP LSHCOL             / Go to next column

       TAD CXPOS              / Inner loop done
       DCA FIELDX             / Store starting X position
       TAD CSHSIZ             / Get width
       CIA                    / Subtract from field position
       TAD FLDPOS             / Get current field position
       TAD (FLDW)             / Move field position to next row
       DCA FLDPOS
       ISZ FIELDY             / Update Y position
       ISZ LOOPJ              / Increment outer loop, one row done
       JMP LSHROW             / Go to next row
       ISZ IFILLM             / legal move, increment return address
       JMP I IFILLM           / All rows done, return to caller.

PRVPOS,
       JMS MEMCPY             / Restore position, rotation, shape and size
       PSHAPE                 / ARG for MEMCPY, copy from previous shape
       CSHAPE                 / ARG for MEMCPY, copy to current shape
       PSHAPE-CSHAPE          / ARG for MEMCPY, size of struct

       TAD DOWNMV
       SNA CLA                / Was this a downwards move?
       JMP I IFILLM           / No, Return
       DCA HRDDRP             / Yes, Reset possible hard drop
       JMS FIXSHP             / and make shape permanent in field
       JMS SPNSHP             / and spawn new shape
       JMP I IFILLM           / Return

/
/ TODO-list:
/

/
/ Wallkick translation
/

/
/ Check if we have reached "bottom" and timer expired.
/

/
/ Check for solid lines
/

/
/ Erase lines
/

/
/ Gravitate field
/

/
/ Calculate hat of seven
/

/
/ Draw field
/
PAGE
DRAWF, 0
       CLA
/      TAD (FIELDP-01+FLDW+FLDW)   / TODO Skip two invisible top lines
       TAD (FIELDP-1)         / Get field pointer -1
       DCA AIX                / Store in auto index register
/      TAD (FLDH-2)           / TODO Loop over visible rows
       TAD (FLDH)             / Get field height
       CIA                    / Invert for loop
       DCA LOOPI              / Put in outer loop variable
ROWS,
       TAD (FLDW)             / Get field width
       CIA                    / Invert for loop
       DCA LOOPJ              / Put in inner loop variable
       TAD ("<)               / Start by outputing <!
       JMS PUTC
       TAD ("!)
       JMS PUTC
COLS,
       TAD I AIX              / Get field cell
       SNA CLA                / Is zero?
       JMP ISBLNK             / Yes, draw a blank/empty cell
ISBLCK,
       TAD ("[)               / No, draw a block: []
       JMS PUTC
       TAD ("])
       JMS PUTC
       JMP ENDCELL            / This cell is done
ISBLNK,
       TAD (".)               / Draw blank: ..
       JMS PUTC
       TAD (".)
       JMS PUTC
ENDCELL,
       ISZ LOOPJ              / Is row done?
       JMP COLS               / No, check next column
       TAD ("!)               / Yes, end by outputing !>
       JMS PUTC
       TAD (">)
       JMS PUTC
       TAD (MOVD-1)           / And move cursor down one step
       JMS PUTS
       TAD ("2)               / Move back 24 (2*width). TODO do this once
       DCA BACK
       TAD ("4)
       DCA BACK+1
       TAD (MOVB-1)
       JMS PUTS
       ISZ LOOPI              / Is all rows done?
       JMP ROWS               / No, do next row
       JMP I DRAWF            / Yes, return

/
/ Draw shape, AC contains location
/
DRAWS, 0
       TAD (-1)
       DCA AIX                / Location of shape is in AC. Store in index register
       TAD CSHSIZ             / Get size (Todo, use argument as PSHP is drawn as well)
       CIA                    / Invert for loop use
       DCA LOOPJ              / Store as outer loop index
BROWS,
       TAD CSHSIZ             / Get size again
       CIA                    / Invert for loop use
       DCA LOOPI              / Stor as inner loop index
BCOLS,
       TAD I AIX              / Walk through shape data
       SZA CLA                / Is shape data set?
       JMP DBLCK              / Yes, Draw block
DBLNK,
       TAD (MOVF-1)           / No, move cursor to "draw" transparent block
       JMS PUTS
       TAD (MOVF-1)
       JMS PUTS
       JMP DCONT              / Continue
DBLCK,
       TAD I DRAWS            / First argument, should we clear?
       SZA CLA                / Is CLEAR argument set?
       JMP DCBLCK             / Yes, should clear block
       TAD ("[)               / No, Draw block by outputing: []
       JMS PUTC
       TAD ("])
       JMS PUTC
       JMP DCONT              / Continue
DCBLCK,
       TAD (".)               / Clear block by outputing two dots
       JMS PUTC
       TAD (".)
       JMS PUTC
DCONT,
       ISZ LOOPI              / Is row done?
       JMP BCOLS              / No, go to next column
       TAD ("0)               / Yes, Move back twize the size of shape
       DCA BACK
       TAD ("0)
       TAD CSHSIZ
       TAD CSHSIZ
       DCA BACK+1
       TAD (MOVB-1)
       JMS PUTS
       TAD (MOVD-1)
       JMS PUTS                 / Move down
       ISZ LOOPJ                / Increment outer loop, one row done
       JMP BROWS                / Go to next row
       ISZ DRAWS                / Skip over argumnet
       NOP
       JMP I DRAWS              / All rows done, return to caller.

PAGE
/ TODO save space by storing shape data as bit fields
SHAPEL,3;SHAL0;SHAL1;SHAL2;SHAL3

SHAL0,   0;0;1
         1;1;1
         0;0;0

SHAL1,   0;1;0
         0;1;0
         0;1;1

SHAL2,   0;0;0
         1;1;1
         1;0;0

SHAL3,   1;1;0
         0;1;0
         0;1;0

SHAPEJ,3;SHAJ0;SHAJ1;SHAJ2;SHAJ3

SHAJ0,   1;0;0
         1;1;1
         0;0;0

SHAJ1,   0;1;1
         0;1;0
         0;1;0

SHAJ2,   0;0;0
         1;1;1
         0;0;1

SHAJ3,   0;1;0
         0;1;0
         1;1;0


SHAPES,3;SHAS0;SHAS1;SHAS2;SHAS3

SHAS0,   0;1;1
         1;1;0
         0;0;0

SHAS1,   0;1;0
         0;1;1
         0;0;1

SHAS2,   0;0;0
         0;1;1
         1;1;0

SHAS3,   1;0;0
         1;1;0
         0;1;0

SHAPEZ,3;SHAZ0;SHAZ1;SHAZ2;SHAZ3

SHAZ0,   1;1;0
         0;1;1
         0;0;0

SHAZ1,   0;0;1
         0;1;1
         0;1;0

SHAZ2,   0;0;0
         1;1;0
         0;1;1

SHAZ3,   0;1;0
         1;1;0
         1;0;0

SHAPET,3;SHAT0;SHAT1;SHAT2;SHAT3

SHAT0,   0;1;0
         1;1;1
         0;0;0

SHAT1,   0;1;0
         0;1;1
         0;1;0

SHAT2,   0;0;0
         1;1;1
         0;1;0

SHAT3,   0;1;0
         1;1;0
         0;1;0

SHAPEO,4;SHAO0;SHAO1;SHAO2;SHAO3

SHAO0,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAO1,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAO2,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAO3,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAPEI,4;SHAI0;SHAI1;SHAI2;SHAI3

SHAI0,   0;0;0;0
         1;1;1;1
         0;0;0;0
         0;0;0;0

SHAI1,   0;0;1;0
         0;0;1;0
         0;0;1;0
         0;0;1;0

SHAI2,   0;0;0;0
         0;0;0;0
         1;1;1;1
         0;0;0;0

SHAI3,   0;1;0;0
         0;1;0;0
         0;1;0;0
         0;1;0;0

PAGE

/
/ Output null terminated mixed case packed string. AC is string loc-1
/
/ TODO allow escaping to Upper/Lower case only
PUTPS,  0
        DCA AIY
PSLOOP,
        TAD I AIY             / Load first word
        DCA TEMP               / Stash word
        TAD TEMP
        BSW                   / Move first half down
        AND (077)
        JMS PUTB              / Unpack one byte
        TAD TEMP               / Get next byte
        AND (077)
        JMS PUTB
        JMP PSLOOP
PUTB,   0
        SNA
        JMP I PUTPS           / Null byte, return
        DCA TEMP2              / Stash byte
        TAD TEMP2
        AND (037)             / Check if space char (five zero bits)
        SZA
        JMP NOSPC
        TAD (040)             / Set space bit otherwise we output `
        JMP ISSPC             / TODO check for actual space, now we miss @
NOSPC,
        CLA
        /TAD TEMP2 / For uppercase version
        /AND (40)
        /SNA CLA
        TAD (100)             / Not space? set char bit
        TAD TEMP2
ISSPC,
        JMS PUTC              / Output
        JMP I PUTB

/
/ Move to X,Y
/
MOVXY,  ESC
        BRA  / [
YPOS,   0
        0
        073  / ;
XPOS,   0
        0
        0110 / H
        0

/
/ Move up
/
MOVU,  ESC
       BRA
UP,    "1
       "A
       0

/
/ Move down
/
MOVD,  ESC
       BRA
DOWN,  "1
       "B
       0

/
/ Move forward
/
MOVF, ESC
      BRA
FORW, "0
      "1
      "C
      0

/
/ Move backward
/
MOVB, ESC
      BRA
BACK, "2
      "4
      "D
      0

/
/ Clear screen
/
ERASE,  ESC
        133 / [
        "2
        "J
        0

PAGE

/
/ Reserve space for game field
/
       PAGE
FIELDP, ZBLOCK FLDS
/       *FIELDP+FLDS
FLDEND, HLT
$
