/ TINT Is Not T***** in PALbart assembly

/ TODO-list:
/ . Wallkick translation
/ . Save space by storing shape data as bit fields
/ . Calculate score
/ . Store hi-scores
/ . Use regular arguments for PUTC and ITOA
/ . Next piece display
/ . Write comments

/ Page layout

/ Page no. 0
/  Storage of global variable such as shape structures, timer limits,
/  shape pointers, loop variables and game state.
/
/  Funtions: MEMSET, MEMCPY, PUTC, PUTS, ITOA

/ Page no. 2
/  Input handling with delay loops and hard drop loop.


/ Page no. 3
/  Game logic, check if input results in legal move, check for full
/  rows and remove, spawn the next piece. Also helper function for
/  time delay.
/
/  Functions: UPDATE, DELAY

/ Page no. 4
/  Functions to make a stuck piece permanent and spawn a new piece.
/
/  Functions: FIXSHP, SPNSHP

/ Page no. 5
/  Game initialization and  game over handling.
/
/  Functions: GAMOVR, INIT

/ Page no. 6
/  Drawning of main screen.
/
/  Functions: REDRAW

/ Page no. 7
/  Check if piece collides with playing field or move is illegal.
/
/  Functions: IFILLM, CALCPO

/ Page no. 8
/  Drawing of playing field and shapes
/
/  Functions: DRAWF, DRAWS

/ Page no. 9
/  Detection and removal of full rows, and gravitation
/
/  Functions: ROWSCN, CLRROW, GRVFLD

/ Page no. 10
/  Memory move helper routine for gravitation.
/
/  Functions: MEMMVR

/ Page no. 11, 12, 13
/  Shape data, each rotation of the basic shapes stored individually

/ Page no. 14
/  Output routines for strings and terminal control.
/
/  Functions: PUTPS, MOVXY, MOVY, MOVD, MOVF, MOVB, ERASE

/ Page no 14 ->
/  Strings and space for playing field.

/
/ Global symbols
/

/ ASCII chars
       ESC=033
       SPACE=040
       LF=012
       CR=015
       BS=010
       DEL=177
       BRA=133

/ Autoindex locations
      AIX=010
      AIY=011
      AIZ=012

/ Constants
      FLDW=012                / Field height
      FLDH=026                / Field width
      FLDS=012^026            / Total size
      TERMW=0120              / Terminal width
      NL0001=CLA IAC          / Microcoded "1"
      NL0002=CLA CLL CML RTL  / Microcoded "2"
      NL0003=CLA CLL CML IAC RAL / Microcoded "3"
      NL0006=CLA CLL CML IAC RTL / Microcoded "6"
      NL7777=CLA CMA          / Microcoded "7777" or "-1"
      NL7776=CLA CMA CLL RAL  / Microcoded "7776" or "-2"

/
/ Page zero global variables
/
       *20

/
/ Shape structures. The current shape and previous shape structure must
/ be of equal size and the variables must be in the same order as the
/ current shape data is copied to the previous shape data when a new
/ block is spawned.
/

LEVEL, 0
NLINES,0
SCORE, 0

CSHAPE,SHAL0                  / Current shape, init to first rotation of L
CXPOS, 0                      / Current X,Y Position
CYPOS, 0
CSHSIZ,3                      / Length of shape square.
CSHROT,0                      / Current rotation index

PSHAPE,SHAL0                  / Previous shape
PXPOS, 0                      / Previous X,Y Position
PYPOS, 0
PSHSIZ,3                      / Previous shape size
PSHROT,0                      / Previous rotation

/
/ Down movement boolean, must be first variable after shape structures,
/ it's used to determine their combined size.
/
DOWNMV,0                      / non-zero if last movement was down
HRDDRP,0                      / User pressed space, hard drop in progress.

SHPIDX,0                      / Current index into SHPLST
SHPLST,SHAPEL                 / List of pointers to shapes
       SHAPEJ
       SHAPES
       SHAPEZ
       SHAPET
       SHAPEO
       SHAPEI
TEMP,  0                      / Temporaries used here and there
TEMP2, 0
LOOPI, 0                      / Loop variables used here and there
LOOPJ, 0

/
/ Time limits
/
/ This code should run on a CPU without real time clock. So we
/ maintain a few "timers" which is just counters. When they reach 0
/ they have timed out. A positive limit just means that the time
/ must wrap arround.
/
/ Timers and their limits should go in the same order, TIMER1 and
/ LIMIT1 must be first as timers are reset by MEMCPYing data at
/ LIMIT1..LIMIT1+(LIMIT1-TIMER1) to TIMER1


TIMER1, 0                     / Main timer for gravity.
TIMER2, 0                     / Two timers necessary for fast CPUs
HRDTIM, -1000                 / Hard drop timer
GRVTIM, -1000                 / Gravity hang timer
LIMIT1, 0                     / TIMER1 limit
LIMIT2, 6500                  / TIMER2 limit
HRDLIM, -1000                 / Hard drop limit
GRVLIM, 377                   / Gravity hang limit

/
/ Globally usefull routines
/

/
/ MEMSET, set memory region to value.
/
/ ARG0 is pointer to region
/ ARG1 is size
/ ARG2 is value
/
/ Size must be >= 1
/

MEMSET,0
       NL7777                 / Load -1
       TAD I MEMSET           / Get address -1
       DCA AIX                / Store in autoindex register
       ISZ MEMSET             / Get next argument
       TAD I MEMSET           / Which is size
       CIA                    / Negate for loop
       DCA LOOPI              / Put in loop variable
       ISZ MEMSET             / Get next argument (value to set)
MSLOOP,
       TAD I MEMSET           / Get value argument
       DCA I AIX              / Store value through autoindex
       ISZ LOOPI              / Is loop done?
       JMP MSLOOP             / No, continue
       ISZ MEMSET             / Yes, setup return address
       JMP I MEMSET           / return

/
/ MEMCPY, copy one region of memory to another
/
/ ARG0 is source address
/ ARG1 is target address
/ ARG2 is size
/
/ Size must be >= 1
/

MEMCPY,0
       NL7777                 / Load -1
       TAD I MEMCPY           / Get source address -1
       DCA AIX                / Store in autoindex register
       ISZ MEMCPY             / Get next argument
       NL7777                 / Load -1
       TAD I MEMCPY           / Which is target address -1
       DCA AIY                / Store in autoindex register
       ISZ MEMCPY             / Get next argument
       TAD I MEMCPY           / Which is size
       CIA                    / Negate for loop use
       DCA LOOPI              / Put in loop variable
       ISZ MEMCPY             / Setup return address
MCLOOP,
       TAD I AIX              / Get value from source
       DCA I AIY              / Store in target
       ISZ LOOPI              / Is loop done?
       JMP MCLOOP             / No, continue
       JMP I MEMCPY           / Yes, return

/
/ Output one char, clear AC
/

PUTC,  0
       TLS                    / Initiate output of content in AC
       TSF                    / Is tty flag set?
       JMP .-1                / No, wait some more
       CLA                    / Yes, Clean up AC
       JMP I PUTC             / Return

/
/ Output null terminated string, one char per word. AC is loc
/

PUTS,   0
        NL7777                / Load -1 to decrement loc
        TAD I PUTS            / Load argument
        ISZ PUTS              / Set up return address
        DCA AIY               / Set up autoindex register
PLOOP,
        TAD I AIY             / Get next char
        SNA                   / Is it zero?
        JMP I PUTS            / Yes, return
        JMS PUTC              / No, output char
        JMP PLOOP             / Do again

/
/ ITOA - Convert integer between 0-99 to double digit ASCII
/        AC has value, ITOA+1 has target address.
/

VALUE,  0
TARGET, 0
ITOA,   0
        DCA VALUE             / Store value to be converterd
        TAD I ITOA            / Get the first argument
        DCA TARGET            / Store it
        ISZ ITOA              / Advance return address
        NOP                   / TODO bum this
        TAD ("0)              / Get ASCII value of 0
        DCA I TARGET          / Store as initial value in target
        TAD VALUE             / Get value
LOOP10, TAD (-12)             / Remove decimal 10
        SPA                   / While value is still positive
        JMP NXTDGT            / Then go to calculating next digit
        ISZ I TARGET          / Increment ASCII value
        JMP LOOP10

NXTDGT, ISZ TARGET            / Advance target pointer
        NOP                   / TODO bum this
        TAD ("0+12)           / Get ASCII 0 + 10 since subtracted 10 below 0
        DCA I TARGET          / Store as result in target
        JMP I ITOA            / Return

PAGE

/
/ Main loop.
/
       *200
       JMS INIT
       KCC
MAIN,  TAD HRDDRP             / Get hard drop flag
       SNA CLA                / Is a hard drop in progress?
       JMP TCONT              / No, continue to next timer
       ISZ HRDTIM             / Yes, has hard drop delay timed out?
       JMP MAIN               / No, check again
       TAD HRDLIM             / Yes, reset hard drop timer
       DCA HRDTIM
       JMP JKEY               / And fake a down move
TCONT, ISZ TIMER1             / Has drop delay timed out?
       JMP INPUT              / No, get input
       ISZ TIMER2             / Yes, has drop delay two also timed out?
       JMP INPUT              / No, get input
       TAD LIMIT1             / Yes reset both timers
       DCA TIMER1
       TAD LIMIT2
       DCA TIMER2
       JMP JKEY               / Then fake a down move
INPUT, KSF                    / Test keyboard flag
       JMP MAIN               / Main event loop
       KRB                    / Read keystroke
       AND (137)              / Get lower bits (mask out case bit)
       SNA                    / If zero, we got NUL or SPACE
       JMP SPCKEY             / Go to space handling
       TAD (200)              / Add parity bit, since the PALBART chars have it
       TAD (-"F)              / Compare to f
       SNA
       JMP FKEY
       TAD ("F-"H)            / Compare to h
       SNA                    / If zero, we got an 'h'
       JMP HKEY               / Go to handling of 'h'
       TAD ("H-"J)            / Compare to j
       SNA
       JMP JKEY
       TAD ("J-"K)            / Compare to k
       SNA
       JMP KKEY
       TAD ("K-"L)            / Compare to l
       SNA
       JMP LKEY
       TAD ("L-"Q)            / Compare to q
       SNA
       HLT
       TAD ("Q-"R)            / Compare to r
       SNA
       JMP RKEY
       JMP MAIN               / Unused key, return to input loop
/
/ Move left
/
HKEY,
       NL7777                 / Load -1
       TAD CXPOS              / Add current x position (move left)
       DCA CXPOS              / Store it
       JMP UPDATE             / Update screen
/
/ Move down
/
JKEY,
       ISZ CYPOS              / Increment current Y position
       ISZ DOWNMV             / Set downward move flag
       JMP UPDATE             / Update screen
/
/ Rotate clockwise
/
KKEY,
       TAD CSHROT             / Get current rotation
       IAC                    / Increment
       AND (3)                / Wrap arround so CSHROT is 0..3
       DCA CSHROT             / Store
       TAD (SHPLST)           / Get address to list of shapes
       TAD SHPIDX             / Add current shape index
       DCA CSHAPE             / Store pointer (use CSHAPE as temp store)
       TAD I CSHAPE           / Dereference to get shape descriptor pointer
       IAC                    / Skip size
       TAD CSHROT             / Jump to current rotation in descriptor array
       DCA CSHAPE             / Store pointer (again CSHAPE as temp store)
       TAD I CSHAPE           / Get current shapes current rotation
       DCA CSHAPE             / Store as current shape
       JMP UPDATE             / Update screen
/
/ Move right
/
LKEY,
       ISZ CXPOS              / Increment X position (move right)
       NOP                    / X might transition from -1 to 0
       JMP UPDATE             / Update screen
/
/ Reset
/
RKEY,
       JMS INIT               / Clear field, reset variables
       JMP MAIN               / Start over, get next action

/
/ Freshen view, redraw
/
FKEY,
       JMS REDRAW
       JMP MAIN
/
/ Hard drop
/
SPCKEY,
       ISZ HRDDRP             / Set hard drop flag
       JMP MAIN               / Handle drop in main event loop

PAGE

/
/ Update playing field and display
/
UPDATE,
       JMS IFILLM             / Check if new position is illegal
       JMP PRVPOS             / Yes, restore previous pos or check for solid lines
                              / No, redraw the shape:

       JMS DRAWS              / Clear previous shape
       PSHAPE                 / Argument for DRAWS, previous shape and position
       1                      / Argument for DRAWS, clear shape

       JMS DRAWS              / Draw current shape
       CSHAPE                 / Argument for DRAWS, current shape and posistion
       0                      / Argument for DRAWS. Do not clear, draw.

       JMS MEMCPY             / Update previous positions after a move
       CSHAPE                 / ARG for MEMCPY, copy from current shape
       PSHAPE                 / ARG for MEMCPY, copy to previous shape
       PSHAPE-CSHAPE          / ARG for MEMCPY, size of struct

       DCA DOWNMV             / Reset DOWNMV boolean
       JMP MAIN               / Get next action

PRVPOS,0
       JMS MEMCPY             / Restore position, rotation, shape and size
       PSHAPE                 / ARG for MEMCPY, copy from previous shape
       CSHAPE                 / ARG for MEMCPY, copy to current shape
       PSHAPE-CSHAPE          / ARG for MEMCPY, size of struct

       TAD DOWNMV
       SNA CLA                / Was this a downwards move?
       JMP MAIN               / No, Return
       TAD CYPOS              / Get current Y position
       SNA CLA                / Is shape at top position
       JMP GAMOVR             / Unable to move down from top line, game over!
       JMS FIXSHP             / and make shape permanent in field
       JMS ROWSCN             / Scan for full rows
       JMP NOROWS             / No full rows found
       JMS CLRROW             / Rows found, clear
       JMS DRAWF              / Redraw field
       JMS DELAY              / Delay for GRVLIM*4096 ISZ
       GRVLIM
       JMS GRVFLD             / Gravitate field
       JMS DRAWF              / Redraw field
NOROWS,
       JMS SPNSHP             / and spawn new shape
       JMS IFILLM             / Check for Block Out (starting cells are blocked)
       JMP GAMOVR             / Yes, game over!
       JMP MAIN               / Return

DECNT1,0
DECNT2,0
DELAY, 0
       TAD I DELAY
       CIA
       DCA DECNT2
       ISZ DELAY
DELAY2,NL0001
       DCA DECNT1
       ISZ DECNT1
       JMP .-1
       ISZ DECNT2
       JMP DELAY2
       JMP I DELAY

PAGE

/
/ FIXSHP, make the current shape permanent at the current position in
/ the game field.
/

FIXPOS,0
FIXSHP,0
       NL7777                 / First setup shape data iterator
       TAD CSHAPE             / Get location of current shape-1
       DCA AIX                / Store in auto index register

       JMS CALCPO             / Get position within game field
       DCA FIXPOS             / Store

       TAD CSHSIZ             / Get size
       CIA                    / Invert for loop use
       DCA LOOPI              / Store as outer loop index
FILOOP,
       TAD CSHSIZ             / Get size again
       CIA                    / Invert for inner loop
       DCA LOOPJ              / Store as inner loop index
FJLOOP,
       TAD I AIX              / Get next block in shape
       SZA                    / Is it zero?
       DCA I FIXPOS           / No, Put it in game field
       ISZ FIXPOS             / Increment field pointer
       ISZ LOOPJ              / Is loop done?
       JMP FJLOOP             / No, get next block in row

       TAD CSHSIZ             / Get shape size again
       CIA                    / Subtract from:
       TAD FIXPOS             / Field position
       TAD (FLDW)             / Add width to get start of next row
       DCA FIXPOS             / Store updated position
       ISZ LOOPI              / Is outer loop done?
       JMP FILOOP             / No, do next row
       JMP I FIXSHP           / Yes, return

/
/ SPNSHP, spawns new shape by resetting current shape structure and
/ getting the next shape in the global shape list.
/

SPNSHP,0
       JMS MEMSET             / Reset all current and previous values
       CSHAPE                 / Arg for MEMSET, starting position
       DOWNMV+1+1-CSHAPE      / size of all variables including DOWNMV and HRDDRP
       0                      / Value to set
       NL0002                 / Add two to SHPIDX (1 to get into 1..7 range, and 1 to increment)
       TAD SHPIDX             / Get SHPIDX
       AND (7)                / Wrap arround at 7
       SZA                    / Did it wrap to 0 ?
       JMP UPDSHP             / No, update shape data
       JMS RNDBAG             / Yes, shuffle bag-of-seven
       SHPLST
       CLA IAC                / Set to 1, first shape
UPDSHP,
       TAD (-1)               / Remove one, so index is 0..6
       DCA SHPIDX             / Store index
       TAD (SHPLST)           / Get SHPLST address
       TAD SHPIDX             / Add index
       DCA CSHAPE             / Temporary store in current shape pointer
       TAD I CSHAPE           / Get pointer to shape descriptor
       DCA CSHAPE             / Again use CSHAPE as temp
       TAD I CSHAPE           / Get size
       DCA CSHSIZ             / Store size val
       NL0001                 / Get bit mask for odd/even bit
       AND CSHSIZ             / Logical AND with shape size to get X position offset
       TAD (3)                / Add three. Pos will be 3 or 4 depending on width
       DCA CXPOS              / Store as X position, piece properly centered
       ISZ CSHAPE             / Skip size
       TAD CSHAPE             / Get pointer to shape rotation list
       DCA CSHAPE             / Again store temporarily in CSHAPE
       TAD I CSHAPE           / Get pointer to actual shape
       DCA CSHAPE             / Store as current shape pointer
       TAD CSHAPE             / Get shape pointer again
       DCA PSHAPE             / And use it to init previous pointer
       TAD CSHSIZ             / Get size
       DCA PSHSIZ             / And init previous size
       JMS MEMCPY             / Reset timers
       LIMIT1                 / ARG for MEMCPY, copy from limits
       TIMER1                 / ARG for MEMCPY, copy to timers
       LIMIT1-TIMER1          / ARG for MEMCPY, number of timers
       JMP I SPNSHP

PAGE

/
/ Game Over
/
GAMOVR,0
       JMS MOVXY
       0
       14
       JMS PUTS
       SNAME
       JMS READLN
       11
       INBUF
       HLT
       JMS INIT
       JMP MAIN

INBUF, ZBLOCK 12

/
/ Init
/
INIT,  0
       JMS PUTS               / Output screen erase control sequence
       ERASE
       JMS MOVXY              / Move cursor to absolute position
       40
       13
       JMS PUTPS              / Output [][]
       TBLOCK
       JMS PUTS               / Move cursor down
       MOVD
       JMS PUTPS              / Output TINT
       TINT
       JMS PUTS               / Move down
       MOVD
       JMS PUTPS              / Output [][]
       TBLOCK
       JMS MOVXY              / Move cursor to absolute position
       34
       26
       JMS PUTS               / Output level select question
       SLEVEL
RLVL,  CLA                    / Ensure empty AC
       KSF                    / Check for input
       JMP .-1                / No, try again
       KRB                    / Yes, read input
       DCA TEMP               / Store locally
       TAD TEMP               / Get it back
       TAD (200)              / Add parity bit
       TAD (-"0)              / Compare to ASCII '0'
       SPA                    / Was it zero or above?
       JMP RLVL               / No, let user try again
       TAD (-11)              / Yes, subract 9
       SMA SZA                / Is the result negativt or zero?
       JMP RLVL               / No, let user try again
       TAD (11)               / Yes, we read a digit between 0-9, add 9 to get the number back
       DCA LEVEL              / Store result in global LEVEL variable
       TAD LEVEL              / Get the level back
       TAD ("0)               / Add ASCII '0'
       JMS PUTC               / Output to terminal
       TAD LEVEL              / Get level again
       BSW
       TAD (6600)             / Add arbitrary loop limit
       DCA LIMIT2             / Store in global LIMIT variable
       
RENTER,CLA                    / Ensure empty AC
       KSF                    / Check for more input
       JMP RENTER             / No, try again
       KRB                    / Yes, read input
       TAD (-BS)              / Compare to backspace
       SNA
       JMP INIT               / If backspace, redo init to get new input
       TAD (BS-CR)            / Compare to enter/return.
       SZA
       JMP RENTER             / Neither BS or CR, try again
       JMS MEMSET             / Input done, reset game field
       FIELDP                 / Arg for MEMSET, pointer to field
       FLDS                   / Arg for MEMSET, field size
       0                      / Arg for MEMSET, value to set
       JMS SPNSHP             / Spawn a new shape
       JMS REDRAW             / Draw field
       JMP I INIT             / Return

PAGE

/
/ REDRAW, clear screen and redraw field
/

REDRAW,0
       JMS PUTS               / Output
       ERASE                  / Erase escape sequence to terminal
       JMS DRAWF              / Draw empty field
       JMS DRAWS              / Redraw current shape
       CSHAPE
       0
       JMS MOVXY
       70
       4
       JMS PUTS
       SKEYS1
       JMS MOVXY
       70
       5
       JMS PUTS
       SKEYS2
       JMS MOVXY
       70
       6
       JMS PUTS
       SKEYS3
       JMS MOVXY
       70
       7
       JMS PUTS
       SKEYS4
       JMP I REDRAW

PAGE

/
/ CALCPO Calculate FLDPOS, leave in AC
/
CALCPO,0
       TAD CYPOS              / Get current Y position
       CMA                    / Negate and subtract 1
       DCA LOOPI              / Store in loop index
       TAD (FIELDP)           / Get field pointer
       JMP .+2                / Skip first add (since Y starts at 0)
ILOOP, TAD (FLDW)             / Add field width to get to next row
       ISZ LOOPI              / Is Y zero?
       JMP ILOOP              / No, add width again
       TAD CXPOS              / Add X offset
       JMP I CALCPO           / Return

/
/ Check possibility
/
/ See if the current posistion/rotation is possible, otherwise restore
/ previous state. First argument is shape.
/

FIELDX,0
FIELDY,0
FLDPOS,0
IFILLM,0
       NL7777                 / First setup shape data iterator
       TAD CSHAPE
       DCA AIX                / AIX is first index register
       TAD CSHSIZ             / Get size
       CIA                    / Invert for loop use
       DCA LOOPJ              / Store as outer loop index

       JMS CALCPO             / Calculate position in field
       DCA FLDPOS             / Store it

       TAD CXPOS              / Get X and Y posistion for later checks
       DCA FIELDX
       TAD CYPOS
       DCA FIELDY

LSHROW,                       / Loop over rows in shape
       TAD CSHSIZ             / Get size again
       CIA                    / Invert for loop use
       DCA LOOPI              / Stor as inner loop index

LSHCOL,                       / Inner loop over columns in shape
       TAD I AIX              / Get shape data
       SNA CLA                / Is shape data zero/blank?
       JMP LDCONT             / Yes, continue with next block
                              / No, check field for collision
                              / 1st. check if X is out of bounds
       TAD FIELDX             / Get X
       SPA CLA                / Check if negative
       JMP I IFILLM           / Yes, return
       TAD (-FLDW)            / Get negative width
       TAD FIELDX             / Add X
       SMA CLA                / Check if positive (FIELDX to big)
       JMP I IFILLM           / Yes, return

                              / 2nd. check y overflow
       TAD (-FLDH)            / Get negative width
       TAD FIELDY             / Add Y
       SMA CLA                / Check if positive (FIELDY to big)
       JMP I IFILLM           / Yes, return

                              / 3. check content
       TAD I FLDPOS           / Get content
       SZA CLA                / Check if it contains block
       JMP I IFILLM           / Yes, return

LDCONT,                       / If we get here, there was no collision
       ISZ FLDPOS             / Move one step in the game field
       ISZ FIELDX             / Increment field X posistion (can be negative)
       NOP
       ISZ LOOPI              / Increment inner loop, one block processed
       JMP LSHCOL             / Go to next column

       TAD CXPOS              / Inner loop done
       DCA FIELDX             / Store starting X position
       TAD CSHSIZ             / Get width
       CIA                    / Subtract from field position
       TAD FLDPOS             / Get current field position
       TAD (FLDW)             / Move field position to next row
       DCA FLDPOS
       ISZ FIELDY             / Update Y position
       ISZ LOOPJ              / Increment outer loop, one row done
       JMP LSHROW             / Go to next row
       ISZ IFILLM             / legal move, increment return address
       JMP I IFILLM           / All rows done, return to caller.

PAGE

/
/ Draw field
/
DRAWF, 0
       JMS MOVXY
       TERMW%2-FLDW-2+1       / Starting XPOS is middle of terminal (Start column is 1)
       3                      / Start row is 3
       TAD (FIELDP-01+FLDW+FLDW) / Skip two invisible top lines
       DCA AIX                / Store in auto index register
       TAD (-FLDH+2)          / Get number of visible rows
       DCA LOOPI              / Put in outer loop variable
ROWS,
       TAD (-FLDW)            / Get field width
       DCA LOOPJ              / Put in inner loop variable
       TAD ("<)               / Start by outputing <!
       JMS PUTC
       TAD ("!)
       JMS PUTC
COLS,
       TAD I AIX              / Get field cell
       SNA CLA                / Is zero?
       JMP ISBLNK             / Yes, draw a blank/empty cell
ISBLCK,
       TAD ("[)               / No, draw a block: []
       JMS PUTC
       TAD ("])
       JMS PUTC
       JMP ENDCELL            / This cell is done
ISBLNK,
       TAD (SPACE)            / Draw blank: ' .'
       JMS PUTC
       TAD (".)
       JMS PUTC
ENDCELL,
       ISZ LOOPJ              / Is row done?
       JMP COLS               / No, check next column
       TAD ("!)               / Yes, end by outputing !>
       JMS PUTC
       TAD (">)
       JMS PUTC
       JMS PUTS               / And move cursor down one step
       MOVD
       JMS PUTS               / Move back 24 (2*width).
       MOVB24
       ISZ LOOPI              / Is all rows done?
       JMP ROWS               / No, do next row
       JMS PUTS
       SBOTM1                 / Draw bottom line <!=====...
       JMS PUTS               / And move cursor down one step
       MOVD
       JMS PUTS               / Move back 24 (2*width).
       MOVB24
       JMS PUTS
       SBOTM2                 / Draw bottom line \/\/\/...
       JMP I DRAWF            / Yes, return

/
/ Draw shape
/
DSHPST,0
DRAWS, 0
       TAD I DRAWS            / Pointer to shape struct is first argument
       ISZ DRAWS              / Skip first argument
       DCA DSHPST             / Store for later use
       NL7777                 / Get -1 to subtract from
       TAD I DSHPST           / Shape pointer
       DCA AIX                / Location of shape is in AC. Store in index register

       ISZ DSHPST             / Move forward in shape struct to:
       TAD I DSHPST           / X position
       CLL RAL                / Multiply by two (each block is double wide)
       TAD (TERMW%2-FLDW+1)   / Add field X offset (Starting column is 1)
       DCA DRAPOS             / Set X argument to MOVXY
       ISZ DSHPST             / Move forward in shape struct to:
       TAD I DSHPST           / Y position
       IAC                    / Starting row is 1
       DCA DRAPOS+1           / Set Y argument to MOVXY
       JMS MOVXY              / Position cursor
DRAPOS,0
       0

       ISZ DSHPST             / Move forward in shape struct to:
       TAD I DSHPST           / Shape size
       CIA                    / Invert for loop use
       DCA LOOPJ              / Store as outer loop index
BROWS,
       TAD I DSHPST           / Get size again
       CIA                    / Invert for loop use
       DCA LOOPI              / Store as inner loop index
BCOLS,
       TAD I AIX              / Walk through shape data
       SNA CLA                / Is shape data set?
       JMP DBLNK              / No, "draw" a transparent block
       NL7776                 / Get -2
       TAD DRAPOS+1           / Add current Y position
       SPA SNA CLA            / If Y position is 1 or 2, "draw" a transparent block
                              / This will skip first two lines above skyline
       JMP DBLNK
DBLCK,
       TAD I DRAWS            / Second argument, should we clear?
       SZA CLA                / Is CLEAR argument set?
       JMP DCBLCK             / Yes, should clear block
       TAD ("[)               / No, Draw block by outputing: []
       JMS PUTC
       TAD ("])
       JMS PUTC
       JMP DCONT              / Continue
DBLNK,
       JMS PUTS               / Move cursor to "draw" transparent block
       MOVF2
       JMP DCONT              / Continue
DCBLCK,
       TAD (SPACE)            / Clear block by outputing: ' .'
       JMS PUTC
       TAD (".)
       JMS PUTC
DCONT,
       ISZ LOOPI              / Is row done?
       JMP BCOLS              / No, go to next column
       ISZ DRAPOS+1           / Yes, update Y position
       TAD I DSHPST           / Size in struct
       CLL RAL                / Multiply by two
       TAD ("0)
       DCA BACK
       JMS PUTS               / Move back twize the size of shape
       MOVBN
       JMS PUTS               / Move down
       MOVD
       ISZ LOOPJ              / Increment outer loop, one row done
       JMP BROWS              / Go to next row
       ISZ DRAWS              / Skip over argumnet
       JMP I DRAWS            / All rows done, return to caller.

PAGE

/
/ ROWSCN, search for full rows
/

/ Look at the rows that the fallen piece might affect. Loop over rows
/ from the piece starting position downwards as many rows as the piece
/ is high.

/ For each full row that is found, put a pointer to it in the DELROW list
/ The DELROW content will that should be removed.


DELROW,1
       2
       3
       4

ROWPOS,0
COLPOS,0
ROWSCN,0
       JMS CALCPO             / Calculate field position
       DCA ROWPOS             / Store
       TAD CXPOS              / Get current X position
       CIA                    / Negate
       TAD (-FLDW)            / Loop precrements ROW, so start one before
       TAD ROWPOS             / Subtract from ROWPOS
       DCA ROWPOS             / ROWPOS now starts at left of field

       TAD CSHSIZ             / Get size,
       CIA                    / Negate for loop
       DCA LOOPI              / Put in outer loop variable
       DCA DELROW             / Initialize list with null pointer
       TAD (DELROW-1)         / Get pointer to delete row list
       DCA AIX                / Initialize auto index register

RLOOPI,
       TAD (-FLDW)            / Get negative field width for loop
       DCA LOOPJ              / Put in inner loop variable
       TAD ROWPOS             / Get ROWPOS
       TAD (FLDW)             / Get next row
       DCA ROWPOS             / Update ROWPOS
       TAD (-FLDEND)          / Get end of field, for bounds check
       TAD ROWPOS             / Compare to row pos
       SMA SZA CLA            / Is inside field?
       JMP ROWEND             / No, finish up
       TAD ROWPOS             / Yes, get ROWPOS
       DCA COLPOS             / And initialize COLPOS for search

RLOOPJ,
       TAD I COLPOS           / Get block from field
       SZA CLA                / Is there a block here?
       JMP ISBLOC             / Yes, handle it below
       JMP ROWCNT             / No, Go to next row

ISBLOC,
       ISZ COLPOS             / Move to next block
       ISZ LOOPJ              / Is row scanned?
       JMP RLOOPJ             / No, check next block
       TAD ROWPOS             / Yes, mark row as deleted
       DCA I AIX              / Put row pointer in deleted rows list

ROWCNT,
       ISZ LOOPI              / Is outer loop done?
       JMP RLOOPI             / No, check next row

ROWEND,
       DCA I AIX              / Put a null terminator DELROW list
       TAD DELROW             / Get pointer to first possible deleted row
       SZA CLA                / Was any full rows detected?
       ISZ ROWSCN             / Yes, skip instruction at return address
       JMP I ROWSCN           / Return

/
/ CLRROW Clear rows
/

CLRROW,0
       TAD (DELROW-1)
       DCA AIZ                / MEMSET uses AIX, Redraw uses AIY
RWLOOP,
       TAD I AIZ
       SNA
       JMP I CLRROW
       DCA CSTART
       JMS MEMSET
CSTART,0
       12
       0
       JMP RWLOOP

/
/ GRVFLD, gravitate field.
/

GRVPOS,0
GRVNXT,0
GRVSIZ,0
GRVFLD,0
       TAD (DELROW)           / Get pointer to list of deleted rows
       DCA GRVPOS             / Store for loop
GILOOP,
       TAD I GRVPOS           / Get next row pointer
       SNA CLA                / Is there something to gravitate?
       JMP I GRVFLD           / No, return
       TAD GRVPOS             / Yes, Get the next pointer
       IAC                    / Move forward
       DCA GRVNXT             / Initialize loop variable for next pointer
       TAD (FLDW)             / Get width of field
       DCA GRVSIZ             / Initialize size
GJLOOP,
       TAD GRVSIZ             / Add current size to:
       TAD I GRVPOS           / Current row
       CIA                    / Invert for comparison
       TAD I GRVNXT           / Compare to next line
       SZA CLA                / Is it consecutive? (zero pointer will fail here too)
       JMP GCONT              / No, continue with gravitation
       TAD (FLDW)             / Get again
       TAD GRVSIZ             / Add to GRVSIZ
       DCA GRVSIZ             / Update GRVSIZ
       ISZ GRVNXT             / Move next pointer forward
       JMP GJLOOP             / And see if next is also consecutive

GCONT,
       TAD (FIELDP)           / Get field pointer
       TAD GRVSIZ             / Add size of gravitated rows
       DCA GTARGT             / Store as target for block move
       TAD (-FIELDP)          / Get field pointer again, subtract from:
       TAD I GRVPOS           / Start of row to gravitate, to get:
       DCA GTARGT+2           / Size argument for memmov
       JMS MEMMVR             / Move block of memory forward
GTARGT,0
       FIELDP
       0
       TAD GRVNXT             / Get pointer to next row not gravitated
       DCA GRVPOS             / Update outer loop pointer
       JMP GILOOP             / And see if there is more to gravitate

PAGE

/
/ MEMMVR, MEMory MoVe Right.
/
/ Move a block of memory to a new address. Moves bytes from the upper
/ end of the block to handle that the target area starts inside the
/ block.
/

MVRSRC,0
MVRTRG,0
MEMMVR,0
       TAD I MEMMVR           / Get target address
       DCA MVRTRG             / Store target
       ISZ MEMMVR             / Move to next argument
       TAD I MEMMVR           / Get source address
       ISZ MEMMVR             / Move to next argument
       TAD I MEMMVR           / Add size, point to one past the end
       DCA MVRSRC             / Store updated source
       TAD I MEMMVR           / Get size
       TAD MVRTRG             / Add to targe, point to on past the end
       DCA MVRTRG             / Store updated target
       TAD I MEMMVR           / Get size
       CIA                    / Invert size for loop
       DCA LOOPI              / Store in loop variable
       ISZ MEMMVR             / Move past last argument

MRLOOP,
       NL7777                 / Subtract 1
       TAD MVRSRC             / From source address
       DCA MVRSRC             / Update source address
       NL7777                 / Subtract 1
       TAD MVRTRG             / From target address
       DCA MVRTRG             / Update target address
       TAD I MVRSRC           / Get next word
       DCA I MVRTRG           / Store in target
       ISZ LOOPI              / Is everything copied?
       JMP MRLOOP             / No, copy next word
       JMP I MEMMVR           / Yes, Return

PAGE

/ Each shape is represented by one word, with the width/height of the
/ bounding square, followed by a list of pointers to each rotation of
/ the shape represented as a pattern in memory. The list is then
/ followed by the shape data.

SHAPEL,3;SHAL0;SHAL1;SHAL2;SHAL3

SHAL0,   0;0;1
         1;1;1
         0;0;0

SHAL1,   0;1;0
         0;1;0
         0;1;1

SHAL2,   0;0;0
         1;1;1
         1;0;0

SHAL3,   1;1;0
         0;1;0
         0;1;0

SHAPEJ,3;SHAJ0;SHAJ1;SHAJ2;SHAJ3

SHAJ0,   1;0;0
         1;1;1
         0;0;0

SHAJ1,   0;1;1
         0;1;0
         0;1;0

SHAJ2,   0;0;0
         1;1;1
         0;0;1

SHAJ3,   0;1;0
         0;1;0
         1;1;0


SHAPES,3;SHAS0;SHAS1;SHAS2;SHAS3

SHAS0,   0;1;1
         1;1;0
         0;0;0

SHAS1,   0;1;0
         0;1;1
         0;0;1

SHAS2,   0;0;0
         0;1;1
         1;1;0

SHAS3,   1;0;0
         1;1;0
         0;1;0

SHAPEZ,3;SHAZ0;SHAZ1;SHAZ2;SHAZ3

SHAZ0,   1;1;0
         0;1;1
         0;0;0

SHAZ1,   0;0;1
         0;1;1
         0;1;0

SHAZ2,   0;0;0
         1;1;0
         0;1;1

SHAZ3,   0;1;0
         1;1;0
         1;0;0

SHAPET,3;SHAT0;SHAT1;SHAT2;SHAT3

SHAT0,   0;1;0
         1;1;1
         0;0;0

SHAT1,   0;1;0
         0;1;1
         0;1;0

SHAT2,   0;0;0
         1;1;1
         0;1;0

SHAT3,   0;1;0
         1;1;0
         0;1;0

SHAPEO,4;SHAO0;SHAO1;SHAO2;SHAO3

SHAO0,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAO1,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAO2,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAO3,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAPEI,4;SHAI0;SHAI1;SHAI2;SHAI3

SHAI0,   0;0;0;0
         1;1;1;1
         0;0;0;0
         0;0;0;0

SHAI1,   0;0;1;0
         0;0;1;0
         0;0;1;0
         0;0;1;0

SHAI2,   0;0;0;0
         0;0;0;0
         1;1;1;1
         0;0;0;0

SHAI3,   0;1;0;0
         0;1;0;0
         0;1;0;0
         0;1;0;0

PAGE

/
/ Output null terminated mixed case packed string. AC is string loc-1
/
/ TODO allow escaping to Upper/Lower case only
PUTPS,  0
        NL7777                / Load -1 in AC
        TAD I PUTPS           / Add string pointer
        ISZ PUTPS             / Setup return address
        DCA AIY               / and put in auto index register
PSLOOP,
        TAD I AIY             / Load first word
        DCA TEMP              / Stash word
        TAD TEMP
        BSW                   / Move first half down
        AND (077)
        JMS PUTB              / Unpack first byte
        TAD TEMP              / Get next byte
        AND (077)
        JMS PUTB              / Unpack next byte
        JMP PSLOOP
PUTB,   0
        SNA                   / Is character null?
        JMP I PUTPS           / Yes, end of string, return
        DCA TEMP2             / No, stash byte
        TAD TEMP2
        AND (037)             / Mask out space bit (lower five)
        SZA                   / Is space bits all zero?
        JMP NOTSPC            / No, print out non-space char
        TAD (040)             / Yes, set space bit otherwise we output `
        JMP ISSPC             / TODO check for actual space, now we miss @
NOTSPC,
        CLA
        /TAD TEMP2 / For uppercase version
        /AND (40)
        /SNA CLA
        TAD (100)             / Not space? set char bit
        TAD TEMP2
ISSPC,
        JMS PUTC              / Output
        JMP I PUTB

/
/ Read string from terminal. Read until CR or LF is seen. Echo input
/
/ First argument is max length (minimum is 1)
/ Second argument is pointer to input buffer
/
MAXLEN,0
MAXITR,0
LASTCH,0
READLN, 0
       TAD I READLN           / Add max lenght of string
       ISZ READLN             / Get next argument
       DCA MAXLEN             / Store locally
       TAD MAXLEN             / Get it back
       CIA                    / Invert for countdown
       DCA MAXITR             / Store locally for bounds check
       NL7777                 / Preload ac with -1
       TAD I READLN           / Get pointer to input buffer
       ISZ READLN             / Skip argument to get return adress
       DCA AIX                / Store in autoindex register
READCH,
       CLA
       KSF                    / Is there any key pressed
       JMP .-1                / No, try again
       KRB                    / Yes, read key
       AND (177)              / Get seven lower bits
       DCA LASTCH             / Store locally
       TAD LASTCH             / Get it back
       TAD (-BS)              / Compare to backspace
       SNA
       JMP UNDOCH             / If BS, remove last read char from inbuf
       TAD (BS-DEL)           / Compare with DEL
       SNA                    / Is it DEL?
       JMP READCH             / Yes, Ignore
       TAD (DEL-CR)           / Compare to CR
       SNA CLA
       JMP I READLN           / Line read, return
       TAD LASTCH             / No, get char again
       AND (140)              / Mask out character group bits
       SNA CLA                / Is char in nonprintable group?
       JMP READCH             / Yes, Ignore it
       TAD MAXITR             / Get remaining buffer space
       SNA CLA                / Is there zero space?
       JMP READCH             / Yes, ignore read char
       TAD LASTCH             / No, get char again
       DCA I AIX              / Store in result buffer.
       TAD LASTCH             / Get it again
       JMS PUTC               / Output
       ISZ MAXITR             / Update read char counter
       NOP
       JMP READCH             / No, read another char

UNDOCH,
       CLA
       TAD MAXLEN             / Load maximum length
       TAD MAXITR             / Subtract space left
       SNA CLA                / Is all space left?
       JMP READCH             / Yes, we are at beginning. Just read another char
       TAD (BS)               / Load BS char
       JMS PUTC               / Output
       NL7777                 / Load -1
       TAD AIX                / and decrement AIX
       DCA AIX                / put result back
       NL7777                 / Load -1
       TAD MAXITR             / and decrement MAXITR (which is inverted)
       DCA MAXITR             / put result back
       JMP READCH             / Read another char

PAGE / Sigh, TODO, redo page numbering

/
/ Move to X,Y
/
MOVXY, 0
       TAD I MOVXY
       JMS ITOA
       XPOS
       ISZ MOVXY
       TAD I MOVXY
       JMS ITOA
       YPOS
       ISZ MOVXY
       JMS PUTS
       MOVSTR
       JMP I MOVXY
MOVSTR,ESC
       BRA  / [
YPOS,  0
       0
       073  / ;
XPOS,  0
       0
       0110 / H
       0

/
/ Move up
/
MOVU,  ESC
       BRA
UP,    "1
       "A
       0

/
/ Move down, one step
/
MOVD,  ESC
       BRA
DOWN,  / Add number here to move multiple lines. Like this: "1
       "B
       0

/
/ Move forward, twice
/
MOVF2,ESC
      BRA
FORW, "2
      "C
      0

/
/ Move backward, 24 steps
/
MOVB24, ESC
        BRA
        "2
        "4
        "D
        0

/
/ Move backward, N steps
/
MOVBN, ESC
       BRA
BACK,  "0
       "D
       0

/
/ Clear screen
/
ERASE,  ESC
        BRA
        "2
        "J
        0

TBLOCK,TEXT "[][]"
TINT,  TEXT "TINT"

PAGE

SLEVEL, ASCII "Start at level (0-9) - "
        0 / String terminator
SLINES, ASCII "Full Lines: "
        0
SCURLEV,ASCII "     Level: "
        0
SSCORE, ASCII "     Score: "
        0
SKEYS1, ASCII "H: left  L: Right"
        0
SKEYS2, ASCII "J: down  K: Rotate"
        0
SKEYS3, ASCII "SPACE: hard drop"
        0
SKEYS4, ASCII "R: new game F: refresh"
        0
SNAME,  ASCII "Enter your name: "
        0
SBOTM1, ASCII "<!====================!>"
	0
SBOTM2, ASCII "  \/\/\/\/\/\/\/\/\/\/"
	0

PAGE

/
/ RAND - Get random number
/
/ Function is DECUS No. 5/8-25

IR,    HLT
       JMP INITRN
RAND,  HLT
       CLA
       TAD LEAST
       RAL
       AND CNST71
       DCA TEMP74
       TAD MIDDLE
       AND CNST70
       TAD TEMP74
       RTL
       RTL
       RAL
       DCA TEMP72
       TAD LEAST
       AND CNST70
       RTL
       RTL
       RAL
       TAD MIDDLE
       DCA TEMP73
       SZL
       ISZ TEMP72
       NOP
       TAD LEAST
       CLL RAL
       SZL
       ISZ TEMP73
       SKP
       ISZ TEMP72
       NOP
       CLL
       TAD LEAST
       DCA LEAST
       TAD MIDDLE
       RAL
       SZL
       ISZ TEMP72
       NOP
       CLL
       TAD TEMP73
       DCA MIDDLE
       TAD MOST
       RAL
       TAD MOST
       TAD TEMP72
       DCA MOST
       TAD MOST
       JMP I RAND
       0000
INITRN,CLA IAC
       DCA LEAST
       DCA MIDDLE
       DCA MOST
       JMP I IR
CNST70,0177
CNST71,7400
TEMP72,0
TEMP73,0
TEMP74,0
/ TODO, init these with fair dice roll
MOST,  1
MIDDLE,2
LEAST, 3

PAGE

/
/ Fisher-Yates Shuffle to implement "bag-of-seven" behaviour.
/
/   v
/ [0123456]
/        ^
/
/ v in the illustration above shows randomized index "i".
/ ^ shows last un-struck index "j". Their values will be
/ swapped and result in:
/
/     v
/ [0623451]
/       ^
/
/ New value of "i" has been randomly selected and "j" has
/ been moved to next un-struck index.
/
/ Modulus of the random value to get "i" is done by masking
/ out the three least significant bits to get random value
/ in the range 0-7. Then the value of "j" is subtracted
/ repeatedly from "i" until it is in range 0-j.
/
/ TODO, make generic with regard to lenght of list
/       by taking SIZLIM and bitmask as arguments

FYI,   0
FYJ,   0
SIZLIM,0
ELMATI,0
ELMATJ,0
ELMTMP,0
ELMPNT,0

RNDBAG,0
       TAD I RNDBAG           / Get pointer to list to shuffle
       ISZ RNDBAG             / Advance argument pointer
       DCA ELMPNT             / Store pointer locally
       TAD (-6)               / Load -6, initial value of -j
       DCA SIZLIM             / Save locally
       NL0006                 / Load 6, initial vaule of j
       DCA FYJ                / Save
       DCA FYI                / Store 0 as initial value of i
SHUFLE,
       JMS RAND               / Get random number
       AND (07)               / Mask out lower bits to get value between 0-7
       TAD SIZLIM             / Subtract maximum allowed index (value of j)
       SMA                    / Is value negative?
       JMP .-2                / No, subtract again
       TAD FYJ                / Yes, add j once to get positive value in range 0-j
       TAD ELMPNT             / Add element pointer, to swap ELMPNT[i] and ELMPNT[j]
       DCA ELMATI             / Store resulting adress for i
       TAD FYJ                / Get j
       TAD ELMPNT             / Add element pointer
       DCA ELMATJ             / Store resulting adress for j
       TAD I ELMATI           / Get element at i
       DCA ELMTMP             / Store temporarily
       TAD I ELMATJ           / Get element at j
       DCA I ELMATI           / Store at position i
       TAD ELMTMP             / Get i element
       DCA I ELMATJ           / Store at position j
       ISZ SIZLIM             / Increment negative j
       JMP RESHUF             / If Non-Zero, do another swap
       JMP I RNDBAG           / If Zero, we are done, return
RESHUF,
       NL7777                 / Decrementj
       TAD FYJ
       JMP SHUFLE             / Perform another swap

PAGE

/
/ Reserve space for game field
/
FIELDP, ZBLOCK FLDS
/       *FIELDP+FLDS
FLDEND, HLT
$


/ Text from original:
/ 
/ wa{e imq?
/ imq        urowenx  s~et
/ 
/ 
/ t e t r i s
/ wa{ urowenx? (0-9) -
/ @ap-
/ polnyh strok:
/ urowenx:
/   s~et:
/   <! . . . . . . . . . .!>
/   <!====================!>
/     \/\/\/\/\/\/\/\/\/\/
/     7: nalewo   9: naprawo
/          8:poworot
/ 	 4:uskoritx  5:sbrositx
/ 	 1: pokazatx  sledu`}u`
/ 	 0:  steretx |tot tekst
/ 	   probel - sbrositx
/ 	   e}e parti`? (da/net) -
/

/ Transcribed and translated
/ baW urowen           == Your level
/ polnyh strok         == Full lines
/ urowen               == level
/ C4ET                 == score
/ nalewo               == left
/ naprawo              == right
/ poworot              == turn/rotate
/ uskorit              == speed up
/ sbrositx             == reset
/ pokazatx sleduIOwuIO == show next
/ steret 3tot tekct    == erase this text
/ probel sbrositx      == space is reset
/ wawe imq             == your name
/ imq urowenx c4et     == name level score
/ ewe partiIO (da/net) == new game (yes/no)
