/ TINT Is Not T***** in PALbart assembly

/ TODO-list:
/ . Draw empty line before gravity
/ . Titlescreen
/ . Wallkick translation
/ . Permute shapelist when SHPIDX wraps to get "bag of seven" behaviour
/ . Save space by storing shape data as bit fields

/ Page layout

/ Page no. 0
/  Storage of global variable such as shape structures, timer limits,
/  shape pointers, loop variables and game state.
/
/  Funtions: MEMSET, MEMCPY, PUTC, PUTS, ITOA

/ Page no. 2
/  Input handling with delay loops and hard drop loop.


/ Page no. 3
/  Game logic, check if input results in legal move, check for full
/  rows and remove, spawn the next piece.
/
/  Functions: UPDATE

/ Page no. 4
/  Functions to make a stuck piece permanent, spawn a new piece,
/  initialize game, redraw the playing field
/
/  Functions: FIXPOS, SPNSHP, INIT, REDRAW

/ Page no. 5
/  Check if piece collides with playing field or move is illegal.
/
/  Functions: IFILLM, CALCPO

/ Page no. 6
/  Drawing of playing field and shapes
/
/  Functions: DRAWF, DRAWS

/ Page no. 7
/  Dection and removal of full rows, and gravitation
/
/  Functions: ROWSCN, CLRROW, GRVFLD

/ Page no. 8
/  Memory move helper routine for gravitation.
/
/  Functions: MEMMVR

/ Page no. 9
/  Shape data, each rotation of the basic shapes stored individually

/ Page no. 10
/  Output routines for strings and terminal control.
/
/  Functions: PUTPS, MOVXY, MOVY, MOVD, MOVF, MOVB, ERASE

/ Page no. 11
/  Space for playing field.

/
/ Global symbols
/

/ ASCII chars
       ESC=033
       SPACE=040
       LF=012
       CR=015
       BRA=133

/ Autoindex locations
      AIX=010
      AIY=011
      AIZ=012

/ Constants
      FLDW=012                / Field height
      FLDH=026                / Field width
      FLDS=012^026            / Total size
      TERMW=0120              / Terminal width
      NL0002=CLA CLL CML RTL  / Microcoded "2"
      NL7777=CLA CMA          / Microcoded "7777" or "-1"

/
/ Page zero global variables
/
       *20

/
/ Shape structures. The current shape and previous shape structure must
/ be of equal size and the variables must be in the same order as the
/ current shape data is copied to the previous shape data when a new
/ block is spawned.
/

CSHAPE,SHAL0                  / Current shape, init to first rotation of L
CXPOS, 0                      / Current X,Y Position
CYPOS, 0
CSHSIZ,3                      / Length of shape square.
CSHROT,0                      / Current rotation index

PSHAPE,SHAL0                  / Previous shape
PXPOS, 0                      / Previous X,Y Position
PYPOS, 0
PSHSIZ,3                      / Previous shape size
PSHROT,0                      / Previous rotation

/
/ Down movement boolean, must be first variable after shape structures,
/ it's used to determine their combined size.
/
DOWNMV,0                      / non-zero if last movement was down
HRDDRP,0                      / User pressed space, hard drop in progress.

SHPIDX,0                      / Current index into SHPLST
SHPLST,SHAPEL                 / List of pointers to shapes
       SHAPEJ
       SHAPES
       SHAPEZ
       SHAPET
       SHAPEO
       SHAPEI
TEMP,  0                      / Temporaries used here and there
TEMP2, 0
LOOPI, 0                      / Loop variables used here and there
LOOPJ, 0

/
/ Time limits
/
/ This code should run on a CPU without real time clock. So we
/ maintain a few "timers" which is just counters. When they reach 0
/ they have timed out. A positive limit just means that the time
/ must wrap arround.
/
/ Timers and their limits should go in the same order, TIMER1 and
/ LIMIT1 must be first as timers are reset by MEMCPYing data at
/ LIMIT1..LIMIT1+(LIMIT1-TIMER1) to TIMER1


TIMER1, 0                     / Main timer for gravity.
TIMER2, 0                     / Two timers necessary for fast CPUs
HRDTIM, -1000                 / Hard drop timer
GRVTIM, -1000                 / Gravity hang timer
LIMIT1, 0                     / TIMER1 limit
LIMIT2, 0                     / TIMER2 limit
HRDLIM, -1000                 / Hard drop limit
GRVLIM, -1000                 / Gravity hang limit

/
/ Globally usefull routines
/

/
/ MEMSET, set memory region to value.
/
/ ARG0 is pointer to region
/ ARG1 is size
/ ARG2 is value
/
/ Size must be >= 1
/

MEMSET,0
       NL7777                 / Load -1
       TAD I MEMSET           / Get address -1
       DCA AIX                / Store in autoindex register
       ISZ MEMSET             / Get next argument
       TAD I MEMSET           / Which is size
       CIA                    / Negate for loop
       DCA LOOPI              / Put in loop variable
       ISZ MEMSET             / Get next argument (value to set)
MSLOOP,
       TAD I MEMSET           / Get value argument
       DCA I AIX              / Store value through autoindex
       ISZ LOOPI              / Is loop done?
       JMP MSLOOP             / No, continue
       ISZ MEMSET             / Yes, setup return address
       JMP I MEMSET           / return

/
/ MEMCPY, copy one region of memory to another
/
/ ARG0 is source address
/ ARG1 is target address
/ ARG2 is size
/
/ Size must be >= 1
/

MEMCPY,0
       NL7777                 / Load -1
       TAD I MEMCPY           / Get source address -1
       DCA AIX                / Store in autoindex register
       ISZ MEMCPY             / Get next argument
       NL7777                 / Load -1
       TAD I MEMCPY           / Which is target address -1
       DCA AIY                / Store in autoindex register
       ISZ MEMCPY             / Get next argument
       TAD I MEMCPY           / Which is size
       CIA                    / Negate for loop use
       DCA LOOPI              / Put in loop variable
       ISZ MEMCPY             / Setup return address
MCLOOP,
       TAD I AIX              / Get value from source
       DCA I AIY              / Store in target
       ISZ LOOPI              / Is loop done?
       JMP MCLOOP             / No, continue
       JMP I MEMCPY           / Yes, return

/
/ Output one char, clear AC
/

PUTC,  0
       TLS                    / Initiate output of content in AC
       TSF                    / Is tty flag set?
       JMP .-1                / No, wait some more
       CLA                    / Yes, Clean up AC
       JMP I PUTC             / Return

/
/ Output null terminated string, one char per word. AC is loc-1
/

PUTS,   0
        DCA AIY               / Set up autoindex register
PLOOP,
        TAD I AIY             / Get next char
        SNA                   / Is it zero?
        JMP I PUTS            / Yes, return
        JMS PUTC              / No, output char
        JMP PLOOP             / Do again

/
/ ITOA - Convert integer between 0-99 to double digit ASCII
/        AC has value, ITOA+1 has target address.
/

VALUE,  0
TARGET, 0
ITOA,   0
        DCA VALUE             / Store value to be converterd
        TAD I ITOA            / Get the first argument
        DCA TARGET            / Store it
        ISZ ITOA              / Advance return address
        NOP                   / TODO bum this
        TAD ("0)              / Get ASCII value of 0
        DCA I TARGET          / Store as initial value in target
        TAD VALUE             / Get value
LOOP10, TAD (-12)             / Remove decimal 10
        SPA                   / While value is still positive
        JMP NXTDGT            / Then go to calculating next digit
        ISZ I TARGET          / Increment ASCII value
        JMP LOOP10

NXTDGT, ISZ TARGET            / Advance target pointer
        NOP                   / TODO bum this
        TAD ("0+12)           / Get ASCII 0 + 10 since subtracted 10 below 0
        DCA I TARGET          / Store as result in target
        JMP I ITOA            / Return

PAGE

/
/ Main loop.
/
       *200
       JMS INIT
       KCC
MAIN,  TAD HRDDRP             / Get hard drop flag
       SNA CLA                / Is a hard drop in progress?
       JMP TCONT              / No, continue to next timer
       ISZ HRDTIM             / Yes, has hard drop delay timed out?
       JMP MAIN               / No, check again
       TAD HRDLIM             / Yes, reset hard drop timer
       DCA HRDTIM
       JMP JKEY               / And fake a down move
TCONT, ISZ TIMER1             / Has drop delay timed out?
       JMP INPUT              / No, get input
       ISZ TIMER2             / Yes, has drop delay two also timed out?
       JMP INPUT              / No, get input
       TAD LIMIT1             / Yes reset both timers
       DCA TIMER1
       TAD LIMIT2
       DCA TIMER2
       JMP JKEY               / Then fake a down move
INPUT, KSF                    / Test keyboard flag
       JMP MAIN               / Main event loop
       KRB                    / Read keystroke
       AND (137)              / Get lower bits (mask out case bit)
       SNA                    / If zero, we got NUL or SPACE
       JMP SPCKEY             / Go to space handling
       TAD (200)              / Add parity bit, since the PALBART chars have it
       TAD (-"F)              / Compare to f
       SNA
       JMP FKEY
       TAD ("F-"H)            / Compare to h
       SNA                    / If zero, we got an 'h'
       JMP HKEY               / Go to handling of 'h'
       TAD ("H-"J)            / Compare to j
       SNA
       JMP JKEY
       TAD ("J-"K)            / Compare to k
       SNA
       JMP KKEY
       TAD ("K-"L)            / Compare to l
       SNA
       JMP LKEY
       TAD ("L-"Q)            / Compare to q
       SNA
       HLT
       TAD ("Q-"R)            / Compare to r
       SNA
       JMP RKEY
       JMP MAIN               / Unused key, return to input loop
/
/ Move left
/
HKEY,
       NL7777                 / Load -1
       TAD CXPOS              / Add current x position (move left)
       DCA CXPOS              / Store it
       JMP UPDATE             / Update screen
/
/ Move down
/
JKEY,
       ISZ CYPOS              / Increment current Y position
       ISZ DOWNMV             / Set downward move flag
       JMP UPDATE             / Update screen
/
/ Rotate clockwise
/
KKEY,
       TAD CSHROT             / Get current rotation
       IAC                    / Increment
       AND (3)                / Wrap arround so CSHROT is 0..3
       DCA CSHROT             / Store
       TAD (SHPLST)           / Get address to list of shapes
       TAD SHPIDX             / Add current shape index
       DCA CSHAPE             / Store pointer (use CSHAPE as temp store)
       TAD I CSHAPE           / Dereference to get shape descriptor pointer
       IAC                    / Skip size
       TAD CSHROT             / Jump to current rotation in descriptor array
       DCA CSHAPE             / Store pointer (again CSHAPE as temp store)
       TAD I CSHAPE           / Get current shapes current rotation
       DCA CSHAPE             / Store as current shape
       JMP UPDATE             / Update screen
/
/ Move right
/
LKEY,
       ISZ CXPOS              / Increment X position (move right)
       NOP                    / X might transition from -1 to 0
       JMP UPDATE             / Update screen
/
/ Reset
/
RKEY,
       JMS INIT               / Clear field, reset variables
       JMP MAIN               / Start over, get next action

/
/ Freshen view, redraw
/
FKEY,
       JMS REDRAW
       JMS DRAWS
       CSHAPE
       0
       JMP MAIN
/
/ Hard drop
/
SPCKEY,
       ISZ HRDDRP             / Set hard drop flag
       JMP MAIN               / Handle drop in main event loop

PAGE

/
/ Update playing field and display
/
UPDATE,
       JMS IFILLM             / Check if new position is illegal
       JMP PRVPOS             / Yes, restore previous pos or check for solid lines
                              / No, redraw the shape:

       JMS DRAWS              / Clear previous shape
       PSHAPE                 / Argument for DRAWS, previous shape and position
       1                      / Argument for DRAWS, clear shape

       JMS DRAWS              / Draw current shape
       CSHAPE                 / Argument for DRAWS, current shape and posistion
       0                      / Argument for DRAWS. Do not clear, draw.

       JMS MEMCPY             / Update previous positions after a move
       CSHAPE                 / ARG for MEMCPY, copy from current shape
       PSHAPE                 / ARG for MEMCPY, copy to previous shape
       PSHAPE-CSHAPE          / ARG for MEMCPY, size of struct

       DCA DOWNMV             / Reset DOWNMV boolean
       JMP MAIN               / Get next action

PRVPOS,0
       JMS MEMCPY             / Restore position, rotation, shape and size
       PSHAPE                 / ARG for MEMCPY, copy from previous shape
       CSHAPE                 / ARG for MEMCPY, copy to current shape
       PSHAPE-CSHAPE          / ARG for MEMCPY, size of struct

       TAD DOWNMV
       SNA CLA                / Was this a downwards move?
       JMP MAIN               / No, Return
       JMS FIXSHP             / and make shape permanent in field
       JMS ROWSCN             / Scan for full rows
/       JMP I IFILLM           / No rows found, return / TODO only do below if necessary
       JMS CLRROW             / Rows found, clear
       JMS REDRAW             / TODO, just redraw cleared row
       JMS GRVFLD             / Gravitate field
       JMS REDRAW             / Refresh full field
       JMS SPNSHP             / and spawn new shape
       JMP MAIN               / Return

PAGE

/
/ FIXPOS, make the current shape permanent at the current position in
/ the game field.
/

FIXPOS,0
FIXSHP,0
       NL7777                 / First setup shape data iterator
       TAD CSHAPE             / Get location of current shape-1
       DCA AIX                / Store in auto index register

       JMS CALCPO             / Get position within game field
       DCA FIXPOS             / Store

       TAD CSHSIZ             / Get size
       CIA                    / Invert for loop use
       DCA LOOPI              / Store as outer loop index
FILOOP,
       TAD CSHSIZ             / Get size again
       CIA                    / Invert for inner loop
       DCA LOOPJ              / Store as inner loop index
FJLOOP,
       TAD I AIX              / Get next block in shape
       SZA                    / Is it zero?
       DCA I FIXPOS           / No, Put it in game field
       ISZ FIXPOS             / Increment field pointer
       ISZ LOOPJ              / Is loop done?
       JMP FJLOOP             / No, get next block in row

       TAD CSHSIZ             / Get shape size again
       CIA                    / Subtract from:
       TAD FIXPOS             / Field position
       TAD (FLDW)             / Add width to get start of next row
       DCA FIXPOS             / Store updated position
       ISZ LOOPI              / Is outer loop done?
       JMP FILOOP             / No, do next row
       JMP I FIXSHP           / Yes, return

/
/ SPNSHP, spawns new shape by resetting current shape structure and
/ getting the next shape in the global shape list.
/

SPNSHP,0
       JMS MEMSET             / Reset all current and previous values
       CSHAPE                 / Arg for MEMSET, starting position
       DOWNMV+1+1-CSHAPE      / size of all variables including DOWNMV and HRDDRP
       0                      / Value to set
       NL0002                 / Add two to SHPIDX (1 to get into 1..7 range, and 1 to increment)
       TAD SHPIDX             / Get SHPIDX
       AND (7)                / Wrap arround at 7
       SZA                    / Did it wrap to 0 ?
       TAD (-1)               / No, remove one, so index is 0..6
       DCA SHPIDX             / Save
       TAD (SHPLST)           / Get SHPLST address
       TAD SHPIDX             / Add index
       DCA CSHAPE             / Temporary store in current shape pointer
       TAD I CSHAPE           / Get pointer to shape descriptor
       DCA CSHAPE             / Again use CSHAPE as temp
       TAD I CSHAPE           / Get size
       DCA CSHSIZ             / Store size val
       ISZ CSHAPE             / Skip size
       TAD CSHAPE             / Get pointer to shape rotation list
       DCA CSHAPE             / Again store temporarily in CSHAPE
       TAD I CSHAPE           / Get pointer to actual shape
       DCA CSHAPE             / Store as current shape pointer
       TAD CSHAPE             / Get shape pointer again
       DCA PSHAPE             / And use it to init previous pointer
       TAD CSHSIZ             / Get size
       DCA PSHSIZ             / And init previous size
       JMS MEMCPY             / Reset timers
       LIMIT1                 / ARG for MEMCPY, copy from limits
       TIMER1                 / ARG for MEMCPY, copy to timers
       LIMIT1-TIMER1          / ARG for MEMCPY, number of timers
       JMP I SPNSHP

/
/ Init
/

INIT,  0
       JMS MEMSET             / Reset game field
       FIELDP                 / Arg for MEMSET, pointer to field
       FLDS                   / Arg for MEMSET, field size
       0                      / Arg for MEMSET, value to set
       JMS REDRAW             / Draw field
       JMS SPNSHP             / Spawn a new shape
       JMP I INIT             / Return

/
/ REDRAW, clear screen and redraw field
/

REDRAW,0
       TAD (ERASE-1)          / Load erase escape sequence
       JMS PUTS               / Output to terminal
       TAD (TERMW%2-FLDW-2+1) / Starting XPOS is middle of terminal (Start column is 1)
       JMS ITOA               / Get ASCII coordinate
       XPOS                   / Target address, argument for ITOA
       CLA IAC                / Start row is 1
       JMS ITOA               / Get ASCII Y coordinate
       YPOS                   / Target address, argument for ITOA
       TAD [MOVXY-1]          / Position cursors
       JMS PUTS
       JMS DRAWF              / Draw empty field / TODO, redraw CSHAPE here ?
       JMP I REDRAW

PAGE

/
/ CALCPO Calculate FLDPOS, leave in AC
/
CALCPO,0
       TAD CYPOS              / Get current Y position
       CMA                    / Negate and subtract 1
       DCA LOOPI              / Store in loop index
       TAD (FIELDP)           / Get field pointer
       JMP .+2                / Skip first add (since Y starts at 0)
ILOOP, TAD (FLDW)             / Add field width to get to next row
       ISZ LOOPI              / Is Y zero?
       JMP ILOOP              / No, add width again
       TAD CXPOS              / Add X offset
       JMP I CALCPO           / Return

/
/ Check possibility
/
/ See if the current posistion/rotation is possible, otherwise restore
/ previous state. First argument is shape.
/

FIELDX,0
FIELDY,0
FLDPOS,0
IFILLM,0
       NL7777                 / First setup shape data iterator
       TAD CSHAPE
       DCA AIX                / AIX is first index register
       TAD CSHSIZ             / Get size
       CIA                    / Invert for loop use
       DCA LOOPJ              / Store as outer loop index

       JMS CALCPO             / Calculate position in field
       DCA FLDPOS             / Store it

       TAD CXPOS              / Get X and Y posistion for later checks
       DCA FIELDX
       TAD CYPOS
       DCA FIELDY

LSHROW,                       / Loop over rows in shape
       TAD CSHSIZ             / Get size again
       CIA                    / Invert for loop use
       DCA LOOPI              / Stor as inner loop index

LSHCOL,                       / Inner loop over columns in shape
       TAD I AIX              / Get shape data
       SNA CLA                / Is shape data zero/blank?
       JMP LDCONT             / Yes, continue with next block
                              / No, check field for collision
                              / 1st. check if X is out of bounds
       TAD FIELDX             / Get X
       SPA CLA                / Check if negative
       JMP I IFILLM           / Yes, return
       TAD (-FLDW)            / Get negative width
       TAD FIELDX             / Add X
       SMA CLA                / Check if positive (FIELDX to big)
       JMP I IFILLM           / Yes, return

                              / 2nd. check y overflow
       TAD (-FLDH)            / Get negative width
       TAD FIELDY             / Add Y
       SMA CLA                / Check if positive (FIELDY to big)
       JMP I IFILLM           / Yes, return

                              / 3. check content
       TAD I FLDPOS           / Get content
       SZA CLA                / Check if it contains block
       JMP I IFILLM           / Yes, return

LDCONT,                       / If we get here, there was no collision
       ISZ FLDPOS             / Move one step in the game field
       ISZ FIELDX             / Increment field X posistion (can be negative)
       NOP
       ISZ LOOPI              / Increment inner loop, one block processed
       JMP LSHCOL             / Go to next column

       TAD CXPOS              / Inner loop done
       DCA FIELDX             / Store starting X position
       TAD CSHSIZ             / Get width
       CIA                    / Subtract from field position
       TAD FLDPOS             / Get current field position
       TAD (FLDW)             / Move field position to next row
       DCA FLDPOS
       ISZ FIELDY             / Update Y position
       ISZ LOOPJ              / Increment outer loop, one row done
       JMP LSHROW             / Go to next row
       ISZ IFILLM             / legal move, increment return address
       JMP I IFILLM           / All rows done, return to caller.

PAGE

/
/ Draw field
/
DRAWF, 0
       CLA
/      TAD (FIELDP-01+FLDW+FLDW)   / TODO Skip two invisible top lines
       TAD (FIELDP-1)         / Get field pointer -1
       DCA AIX                / Store in auto index register
/      TAD (FLDH-2)           / TODO Loop over visible rows
       TAD (FLDH)             / Get field height
       CIA                    / Invert for loop / TODO bum this
       DCA LOOPI              / Put in outer loop variable
ROWS,
       TAD (FLDW)             / Get field width
       CIA                    / Invert for loop / TODO bum this
       DCA LOOPJ              / Put in inner loop variable
       TAD ("<)               / Start by outputing <!
       JMS PUTC
       TAD ("!)
       JMS PUTC
COLS,
       TAD I AIX              / Get field cell
       SNA CLA                / Is zero?
       JMP ISBLNK             / Yes, draw a blank/empty cell
ISBLCK,
       TAD ("[)               / No, draw a block: []
       JMS PUTC
       TAD ("])
       JMS PUTC
       JMP ENDCELL            / This cell is done
ISBLNK,
       TAD (".)               / Draw blank: ..
       JMS PUTC
       TAD (".)
       JMS PUTC
ENDCELL,
       ISZ LOOPJ              / Is row done?
       JMP COLS               / No, check next column
       TAD ("!)               / Yes, end by outputing !>
       JMS PUTC
       TAD (">)
       JMS PUTC
       TAD (MOVD-1)           / And move cursor down one step
       JMS PUTS
       TAD ("2)               / Move back 24 (2*width). TODO do this once
       DCA BACK
       TAD ("4)
       DCA BACK+1
       TAD (MOVB-1)
       JMS PUTS
       ISZ LOOPI              / Is all rows done?
       JMP ROWS               / No, do next row
       JMP I DRAWF            / Yes, return

/
/ Draw shape, AC contains location
/
DSHPST,0
DSHAPE,0
DRAWS, 0
       TAD I DRAWS            / Pointer to shape struct is first argument
       ISZ DRAWS              / Skip first argument
       DCA DSHPST             / Store for later use
       TAD I DSHPST           / Shape pointer
       DCA DSHAPE             / Store shape for later use
       NL7777                 / Get -1 to subtract from
       TAD DSHAPE             / Shape data pointer
       DCA AIX                / Location of shape is in AC. Store in index register

       ISZ DSHPST             / Move forward in shape struct to:
       TAD I DSHPST           / X position
       CLL RAL                / Multiply by two (each block is double wide)
       TAD (TERMW%2-FLDW+1)   / Add field X offset (Starting column is 1) / TODO argument?
       JMS ITOA               / Get ASCII X coordinate
       XPOS                   / Target address, argument for ITOA
       ISZ DSHPST             / Move forward in shape struct to:
       TAD I DSHPST           / Y position
       IAC                    / Starting row is 1
       JMS ITOA               / Get ASCII Y coordinate
       YPOS                   / Target address, argument for ITOA
       TAD [MOVXY-1]          / Get pointer to move string
       JMS PUTS               / Position cursor

       ISZ DSHPST             / Move forward in shape struct to:
       TAD I DSHPST           / Shape size
       CIA                    / Invert for loop use
       DCA LOOPJ              / Store as outer loop index
BROWS,
       TAD I DSHPST           / Get size again
       CIA                    / Invert for loop use
       DCA LOOPI              / Stor as inner loop index
BCOLS,
       TAD I AIX              / Walk through shape data
       SZA CLA                / Is shape data set?
       JMP DBLCK              / Yes, Draw block
DBLNK,
       TAD (MOVF-1)           / No, move cursor to "draw" transparent block
       JMS PUTS
       TAD (MOVF-1)
       JMS PUTS
       JMP DCONT              / Continue
DBLCK,
       TAD I DRAWS            / Second argument, should we clear?
       SZA CLA                / Is CLEAR argument set?
       JMP DCBLCK             / Yes, should clear block
       TAD ("[)               / No, Draw block by outputing: []
       JMS PUTC
       TAD ("])
       JMS PUTC
       JMP DCONT              / Continue
DCBLCK,
       TAD (".)               / Clear block by outputing two dots
       JMS PUTC
       TAD (".)
       JMS PUTC
DCONT,
       ISZ LOOPI              / Is row done?
       JMP BCOLS              / No, go to next column
       TAD ("0)               / Yes, Move back twize the size of shape
       DCA BACK
       TAD I DSHPST           / Size in struct
       CLL RAL                / Multiply by two
       TAD ("0)
       DCA BACK+1
       TAD (MOVB-1)
       JMS PUTS
       TAD (MOVD-1)
       JMS PUTS               / Move down
       ISZ LOOPJ              / Increment outer loop, one row done
       JMP BROWS              / Go to next row
       ISZ DRAWS              / Skip over argumnet
       JMP I DRAWS            / All rows done, return to caller.

PAGE

/
/ ROWSCN, search for full rows
/

/ Look at the rows that the fallen piece might affect. Loop over rows
/ from the piece starting position downwards as many rows as the piece
/ is high.

/ For each full row that is found, put a pointer to it in the DELROW list
/ The DELROW content will that should be removed.


DELROW,1
       2
       3
       4

ROWPOS,0
COLPOS,0
ROWSCN,0
       JMS CALCPO             / Calculate field position
       DCA ROWPOS             / Store
       TAD CXPOS              / Get current X position
       CIA                    / Negate
       TAD (-FLDW)            / Loop precrements ROW, so start one before
       TAD ROWPOS             / Subtract from ROWPOS
       DCA ROWPOS             / ROWPOS now starts at left of field

       TAD CSHSIZ             / Get size,
       CIA                    / Negate for loop
       DCA LOOPI              / Put in outer loop variable
       DCA DELROW             / Initialize list with null pointer
       TAD (DELROW-1)         / Get pointer to deleter row list
       DCA AIX                / Initialize auto index register

RLOOPI,
       TAD (-FLDW)            / Get negative field width for loop
       DCA LOOPJ              / Put in inner loop variable
       TAD ROWPOS             / Get ROWPOS
       TAD (FLDW)             / Get next row
       DCA ROWPOS             / Update ROWPOS
       TAD (-FLDEND)          / Get end of field, for bounds check
       TAD ROWPOS             / Compare to row pos
       SMA SZA CLA            / Is inside field?
       JMP ROWEND             / No, finish up
       TAD ROWPOS             / Yes, get ROWPOS
       DCA COLPOS             / And initialize COLPOS for search

RLOOPJ,
       TAD I COLPOS           / Get block from field
       SZA CLA                / Is there a block here?
       JMP ISBLOC             / Yes, handle it below
       JMP ROWCNT             / No, Go to next row

ISBLOC,
       ISZ COLPOS             / Move to next block
       ISZ LOOPJ              / Is row scanned?
       JMP RLOOPJ             / No, check next block
       TAD ROWPOS             / Yes, mark row as deleted
       DCA I AIX              / Put row pointer in deleted rows list

ROWCNT,
       ISZ LOOPI              / Is outer loop done?
       JMP RLOOPI             / No, check next row

ROWEND,
       DCA I AIX              / Put a null terminator DELROW list
/       TAD DELROW             / Get first deleted row
/       SZA CLA                / Was at least one row deleted?
/       ISZ ROWSCN             / Yes, skip instruction at return address
       JMP I ROWSCN

/
/ CLRROW Clear rows
/

CLRROW,0
       TAD (DELROW-1)
       DCA AIZ                / MEMSET uses AIX, Redraw uses AIY
RWLOOP,
       TAD I AIZ
       SNA
       JMP I CLRROW
       DCA CSTART
       JMS MEMSET
CSTART,0
       12
       0
       JMP RWLOOP

/
/ GRVFLD, gravitate field.
/

GRVPOS,0
GRVNXT,0
GRVSIZ,0
GRVFLD,0
       TAD (DELROW)           / Get pointer to list of deleted rows / TODO as argument
       DCA GRVPOS             / Store for loop
GILOOP,
       TAD I GRVPOS           / Get next row pointer
       SNA CLA                / Is there something to gravitate?
       JMP I GRVFLD           / No, return
       TAD GRVPOS             / Yes, Get the next pointer
       IAC                    / Move forward
       DCA GRVNXT             / Initialize loop variable for next pointer
       TAD (FLDW)             / Get width of field
       DCA GRVSIZ             / Initialize size
GJLOOP,
       TAD GRVSIZ             / Add current size to:
       TAD I GRVPOS           / Current row
       CIA                    / Invert for comparison
       TAD I GRVNXT           / Compare to next line
       SZA CLA                / Is it consecutive? (zero pointer will fail here too)
       JMP GCONT              / No, continue with gravitation
       TAD (FLDW)             / Get again
       TAD GRVSIZ             / Add to GRVSIZ
       DCA GRVSIZ             / Update GRVSIZ
       ISZ GRVNXT             / Move next pointer forward
       JMP GJLOOP             / And see if next is also consecutive

GCONT,
       TAD (FIELDP)           / Get field pointer
       TAD GRVSIZ             / Add size of gravitated rows
       DCA GTARGT             / Store as target for block move
       TAD (-FIELDP)          / Get field pointer again, subtract from:
       TAD I GRVPOS           / Start of row to gravitate, to get:
       DCA GTARGT+2           / Size argument for memmov
       JMS MEMMVR             / Move block of memory forward
GTARGT,0
       FIELDP
       0
       TAD GRVNXT             / Get pointer to next row not gravitated
       DCA GRVPOS             / Update outer loop pointer
       JMP GILOOP             / And see if there is more to gravitate

PAGE

/
/ MEMMVR, MEMory MoVe Right.
/
/ Move a block of memory to a new address. Moves bytes from the upper
/ end of the block to handle that the target area starts inside the
/ block.
/

MVRSRC,0
MVRTRG,0
MEMMVR,0
       TAD I MEMMVR           / Get target address
       DCA MVRTRG             / Store target
       ISZ MEMMVR             / Move to next argument
       TAD I MEMMVR           / Get source address
       ISZ MEMMVR             / Move to next argument
       TAD I MEMMVR           / Add size, point to one past the end
       DCA MVRSRC             / Store updated source
       TAD I MEMMVR           / Get size
       TAD MVRTRG             / Add to targe, point to on past the end
       DCA MVRTRG             / Store updated target
       TAD I MEMMVR           / Get size
       CIA                    / Invert size for loop
       DCA LOOPI              / Store in loop variable
       ISZ MEMMVR             / Move past last argument

MRLOOP,
       NL7777                 / Subtract 1
       TAD MVRSRC             / From source address
       DCA MVRSRC             / Update source address
       NL7777                 / Subtract 1
       TAD MVRTRG             / From target address
       DCA MVRTRG             / Update target address
       TAD I MVRSRC           / Get next word
       DCA I MVRTRG           / Store in target
       ISZ LOOPI              / Is everything copied?
       JMP MRLOOP             / No, copy next word
       JMP I MEMMVR           / Yes, Return

PAGE

/ Each shape is represented by one word, with the width/height of the
/ bounding square, followed by a list of pointers to each rotation of
/ the shape represented as a pattern in memory. The list is then
/ followed by the shape data.

SHAPEL,3;SHAL0;SHAL1;SHAL2;SHAL3

SHAL0,   0;0;1
         1;1;1
         0;0;0

SHAL1,   0;1;0
         0;1;0
         0;1;1

SHAL2,   0;0;0
         1;1;1
         1;0;0

SHAL3,   1;1;0
         0;1;0
         0;1;0

SHAPEJ,3;SHAJ0;SHAJ1;SHAJ2;SHAJ3

SHAJ0,   1;0;0
         1;1;1
         0;0;0

SHAJ1,   0;1;1
         0;1;0
         0;1;0

SHAJ2,   0;0;0
         1;1;1
         0;0;1

SHAJ3,   0;1;0
         0;1;0
         1;1;0


SHAPES,3;SHAS0;SHAS1;SHAS2;SHAS3

SHAS0,   0;1;1
         1;1;0
         0;0;0

SHAS1,   0;1;0
         0;1;1
         0;0;1

SHAS2,   0;0;0
         0;1;1
         1;1;0

SHAS3,   1;0;0
         1;1;0
         0;1;0

SHAPEZ,3;SHAZ0;SHAZ1;SHAZ2;SHAZ3

SHAZ0,   1;1;0
         0;1;1
         0;0;0

SHAZ1,   0;0;1
         0;1;1
         0;1;0

SHAZ2,   0;0;0
         1;1;0
         0;1;1

SHAZ3,   0;1;0
         1;1;0
         1;0;0

SHAPET,3;SHAT0;SHAT1;SHAT2;SHAT3

SHAT0,   0;1;0
         1;1;1
         0;0;0

SHAT1,   0;1;0
         0;1;1
         0;1;0

SHAT2,   0;0;0
         1;1;1
         0;1;0

SHAT3,   0;1;0
         1;1;0
         0;1;0

SHAPEO,4;SHAO0;SHAO1;SHAO2;SHAO3

SHAO0,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAO1,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAO2,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAO3,   0;1;1;0
         0;1;1;0
         0;0;0;0
         0;0;0;0

SHAPEI,4;SHAI0;SHAI1;SHAI2;SHAI3

SHAI0,   0;0;0;0
         1;1;1;1
         0;0;0;0
         0;0;0;0

SHAI1,   0;0;1;0
         0;0;1;0
         0;0;1;0
         0;0;1;0

SHAI2,   0;0;0;0
         0;0;0;0
         1;1;1;1
         0;0;0;0

SHAI3,   0;1;0;0
         0;1;0;0
         0;1;0;0
         0;1;0;0

PAGE

/
/ Output null terminated mixed case packed string. AC is string loc-1
/
/ TODO allow escaping to Upper/Lower case only
PUTPS,  0
        NL7777                / Load -1 in AC
        TAD I PUTPS           / Add string pointer
        DCA AIY               / and put in auto index register
PSLOOP,
        TAD I AIY             / Load first word
        DCA TEMP              / Stash word
        TAD TEMP
        BSW                   / Move first half down
        AND (077)
        JMS PUTB              / Unpack first byte
        TAD TEMP              / Get next byte
        AND (077)
        JMS PUTB              / Unpack next byte
        JMP PSLOOP
PUTB,   0
        SNA                   / Is character null?
        JMP I PUTPS           / Yes, end of string, return
        DCA TEMP2             / No, stash byte
        TAD TEMP2
        AND (037)             / Mask out space bit (lower five)
        SZA                   / Is space bits all zero?
        JMP NOTSPC            / No, print out non-space char
        TAD (040)             / Yes, set space bit otherwise we output `
        JMP ISSPC             / TODO check for actual space, now we miss @
NOTSPC,
        CLA
        /TAD TEMP2 / For uppercase version
        /AND (40)
        /SNA CLA
        TAD (100)             / Not space? set char bit
        TAD TEMP2
ISSPC,
        JMS PUTC              / Output
        JMP I PUTB

/
/ Move to X,Y
/
MOVXY,  ESC
        BRA  / [
YPOS,   0
        0
        073  / ;
XPOS,   0
        0
        0110 / H
        0

/
/ Move up
/
MOVU,  ESC
       BRA
UP,    "1
       "A
       0

/
/ Move down
/
MOVD,  ESC
       BRA
DOWN,  "1
       "B
       0

/
/ Move forward
/
MOVF, ESC
      BRA
FORW, "0
      "1
      "C
      0

/
/ Move backward
/
MOVB, ESC
      BRA
BACK, "2
      "4
      "D
      0

/
/ Clear screen
/
ERASE,  ESC
        133 / [
        "2
        "J
        0

PAGE

/
/ Reserve space for game field
/
FIELDP, ZBLOCK FLDS
/       *FIELDP+FLDS
FLDEND, HLT
$


/ Text from original:
/ 
/ wa{e imq?
/ imq        urowenx  s~et
/ 
/ 
/ t e t r i s
/ wa{ urowenx? (0-9) -
/ @ap-
/ polnyh strok:
/ urowenx:
/   s~et:
/   <! . . . . . . . . . .!>
/   <!====================!>
/     \/\/\/\/\/\/\/\/\/\/
/     7: nalewo   9: naprawo
/          8:poworot
/ 	 4:uskoritx  5:sbrositx
/ 	 1: pokazatx  sledu`}u`
/ 	 0:  steretx |tot tekst
/ 	   probel - sbrositx
/ 	   e}e parti`? (da/net) -
/

/ Transcribed and translated
/ baW urowen           == Your level
/ polnyh strok         == Full lines
/ urowen               == level
/ C4ET                 == score
/ nalewo               == left
/ naprawo              == right
/ poworot              == turn/rotate
/ uskorit              == speed up
/ sbrositx             == reset
/ pokazatx sleduIOwuIO == show next
/ steret 3tot tekct    == erase this text
/ probel sbrositx      == space is reset
/ wawe imq             == your name
/ imq urowenx c4et     == name level score
/ ewe partiIO (da/net) == new game (yes/no)
